import{computed as a,toValue as e,ref as t,shallowRef as n,toRef as r,nextTick as s,unref as u,getCurrentInstance as l,onServerPrefetch as i}from"vue";import{e as o,f as c,d}from"./server.mjs";const y={trailing:!0};function debounce(a,e=25,t={}){if(t={...y,...t},!Number.isFinite(e))throw new TypeError("Expected `wait` to be a finite number");let n,r,s,u,l=[];const applyFn=(e,n)=>(s=async function(a,e,t){return await a.apply(e,t)}(a,e,n),s.finally(()=>{if(s=null,t.trailing&&u&&!r){const a=applyFn(e,u);return u=null,a}}),s),debounced=function(...a){return t.trailing&&(u=a),s||new Promise(s=>{const i=!r&&t.leading;clearTimeout(r),r=setTimeout(()=>{r=null;const e=t.leading?n:applyFn(this,a);u=null;for(const a of l)a(e);l=[]},e),i?(n=applyFn(this,a),s(n)):l.push(s)})},_clearTimeout=a=>{a&&(clearTimeout(a),r=null)};return debounced.isPending=()=>!!r,debounced.cancel=()=>{_clearTimeout(r),l=[],u=null},debounced.flush=()=>{if(_clearTimeout(r),!u||s)return;const a=u;return u=null,applyFn(this,a)},debounced}function f(...y){var D;const h="string"==typeof y[y.length-1]?y.pop():void 0;var g,P;g=y[0],P=y[1],!("string"==typeof g||"object"==typeof g&&null!==g||"function"==typeof g&&"function"==typeof P)&&y.unshift(h);let[w,x,b={}]=y;const k=a(()=>e(w));if("string"!=typeof k.value)throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if("function"!=typeof x)throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const T=o();null!=b.server||(b.server=!0),null!=b.default||(b.default=_),null!=b.getCachedData||(b.getCachedData=m),null!=b.lazy||(b.lazy=!1),null!=b.immediate||(b.immediate=!0),null!=b.deep||(b.deep=c.deep),null!=b.dedupe||(b.dedupe="cancel"),b._functionName,T._asyncData[k.value];const C={cause:"initial",dedupe:b.dedupe};if((null==(D=T._asyncData[k.value])?void 0:D._init)||(C.cachedData=b.getCachedData(k.value,T,{cause:"initial"}),T._asyncData[k.value]=function(a,e,l,i,o){var y;null!=(y=a.payload._errors)[e]||(y[e]=c.errorValue);const D=i.getCachedData!==m,h=l,g=i.deep?t:n,P=null!=o,w=a.hook("app:data:refresh",async a=>{a&&!a.includes(e)||await x.execute({cause:"refresh:hook"})}),x={data:g(P?o:i.default()),pending:n(!P),error:r(a.payload._errors,e),status:n("idle"),execute:(...t)=>{var n,r;const[s,l]=t,o=s&&void 0===l&&"object"==typeof s?s:{};if(a._asyncDataPromises[e]){if("defer"===(y=null!=(n=o.dedupe)?n:i.dedupe)||!1===y)return a._asyncDataPromises[e];a._asyncDataPromises[e].cancelled=!0}var y;if("initial"===o.cause||a.isHydrating){const t="cachedData"in o?o.cachedData:i.getCachedData(e,a,{cause:null!=(r=o.cause)?r:"refresh:manual"});if(null!=t)return a.payload.data[e]=x.data.value=t,x.error.value=c.errorValue,x.status.value="success",Promise.resolve(t)}x.pending.value=!0,x.status.value="pending";const D=new Promise((e,t)=>{try{e(h(a))}catch(a){t(a)}}).then(async t=>{if(D.cancelled)return a._asyncDataPromises[e];let n=t;i.transform&&(n=await i.transform(t)),i.pick&&(n=function(a,e){const t={};for(const n of e)t[n]=a[n];return t}(n,i.pick)),a.payload.data[e]=n,x.data.value=n,x.error.value=c.errorValue,x.status.value="success"}).catch(t=>{if(D.cancelled)return a._asyncDataPromises[e];x.error.value=d(t),x.data.value=u(i.default()),x.status.value="error"}).finally(()=>{D.cancelled||(x.pending.value=!1,delete a._asyncDataPromises[e])});return a._asyncDataPromises[e]=D,a._asyncDataPromises[e]},_execute:debounce((...a)=>x.execute(...a),0,{leading:!0}),_default:i.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{var t;w(),(null==(t=a._asyncData[e])?void 0:t._init)&&(a._asyncData[e]._init=!1),D||s(()=>{var t;(null==(t=a._asyncData[e])?void 0:t._init)||(p(a,e),x.execute=()=>Promise.resolve(),x.data.value=c.value)})}};return x}(T,k.value,x,b,C.cachedData)),T._asyncData[k.value]._deps++,!1!==b.server&&T.payload.serverRendered&&b.immediate){const a=T._asyncData[k.value].execute(C);l()?i(()=>a):T.hook("app:created",async()=>{await a})}const V={data:v(()=>{var a;return null==(a=T._asyncData[k.value])?void 0:a.data}),pending:v(()=>{var a;return null==(a=T._asyncData[k.value])?void 0:a.pending}),status:v(()=>{var a;return null==(a=T._asyncData[k.value])?void 0:a.status}),error:v(()=>{var a;return null==(a=T._asyncData[k.value])?void 0:a.error}),refresh:(...a)=>T._asyncData[k.value].execute(...a),execute:(...a)=>T._asyncData[k.value].execute(...a),clear:()=>p(T,k.value)},j=Promise.resolve(T._asyncDataPromises[k.value]).then(()=>V);return Object.assign(j,V),j}function v(e){return a({get:()=>{var a;return null==(a=e())?void 0:a.value},set(a){const t=e();t&&(t.value=a)}})}function p(a,e){e in a.payload.data&&(a.payload.data[e]=void 0),e in a.payload._errors&&(a.payload._errors[e]=c.errorValue),a._asyncData[e]&&(a._asyncData[e].data.value=void 0,a._asyncData[e].error.value=c.errorValue,a._asyncData[e].pending.value=!1,a._asyncData[e].status.value="idle"),e in a._asyncDataPromises&&(a._asyncDataPromises[e]&&(a._asyncDataPromises[e].cancelled=!0),a._asyncDataPromises[e]=void 0)}const _=()=>c.value,m=(a,e,t)=>e.isHydrating?e.payload.data[a]:"refresh:manual"!==t.cause&&"refresh:hook"!==t.cause?e.static.data[a]:void 0;export{f};
//# sourceMappingURL=asyncData-B7xdkuq0.mjs.map
