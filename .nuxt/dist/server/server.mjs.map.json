{"file":"server.mjs","mappings":"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","names":["globalThis","$fetch","create","baseURL","global","nuxtLinkDefaults","componentName","asyncDataDefaults","value","errorValue","deep","appId","getNuxtAppCtx","id","getContext","asyncContext","NuxtPluginIndicator","registerPluginHooks","nuxtApp","plugin","hooks","addHooks","defineNuxtPlugin","_name","name","Object","assign","setup","callWithNuxt","nuxt","args","fn","nuxtAppCtx","_id","vueApp","runWithContext","callAsync","tryUseNuxtApp","nuxtAppInstance","hasInjectionContext","getCurrentInstance","appContext","app","$nuxt","tryUse","useNuxtApp","Error","useRuntimeConfig","_event","$config","defineGetter","obj","key","val","defineProperty","get","LayoutMetaSymbol","Symbol","PageRouteSymbol","url","replace","useRouter","$router","useRoute","inject","_route","defineNuxtRouteMiddleware","middleware","URL_QUOTE_RE","navigateTo","to","options","toPath","resolveRouteObject","resolve","href","isExternalHost","hasProtocol","acceptRelative","isExternal","external","protocol","URL","isScriptProtocol","inMiddleware","_processingMiddleware","isProcessingMiddleware","router","ssrContext","fullPath","location2","joinURL","redirect","async","response","callHook","encodedLoc","encodedHeader","pathname","search","hash","startsWith","toString","encodeURL","_renderResponse","statusCode","sanitizeStatusCode","redirectCode","body","headers","location","afterEach","final","_scope","stop","isHydrating","Promise","push","withQuery","path","query","NUXT_ERROR_SIGNATURE","useError","toRef","payload","showError","error","nuxtError","createError","error2","isNuxtError","createH3Error","configurable","writable","unhead_k2P3m_ZDyjlr2mMYnoDPwavjsDN8hBlk9cFai0bbopU","enforce","head","use","toArray","Array","isArray","_routes","component","import","ROUTE_KEY_PARENTHESES_RE","ROUTE_KEY_SYMBOLS_RE","ROUTE_KEY_NORMAL_RE","generateRouteKey","route","source","meta","r","params","slice","_getHashElementScrollMarginTop","selector","elem","querySelector","Number","parseFloat","getComputedStyle","scrollMarginTop","documentElement","scrollPaddingTop","_calculatePosition","from","savedPosition","defaultHashScrollBehaviour","isPageNavigation","START_LOCATION","matched","every","comp","index","components","default","isChangingPage","el","top","behavior","left","routerOptions","hashMode","scrollBehaviorType","scrollBehavior","hashScrollBehaviour","scrollToTop","hookToWait","_runningTransition","hookOnce","requestAnimationFrame","globalMiddleware","__temp","__restore","validate","__executeAsync","result","fatal","statusMessage","data","namedMiddleware","routerBase","history","createMemoryHistory","routes","startPosition","createRouter","unsub","beforeEach","scrollRestoration","previousRoute","shallowRef","currentRoute","_to","config","globalProperties","initialURL","syncCurrentRoute","hook","length","enumerable","shallowReactive","named","islandContext","_from","failure","type","redirectedFrom","isReady","resolvedInitialRoute","provide","initialLayout","state","_layout","reactive","isReadonly","layout","middlewareEntries","Set","_middleware","componentMiddleware","entry","add","arg","_preloadManifest","_routeRulesMatcher","toRouteMatcher","createRadixRouter","nitro","routeRules","defu","matchAll","reverse","getRouteRules","appMiddleware","delete","then","err","onError","force","injectHead","headSymbol","useHead","input","headCore","useSeoMeta","seoMeta","definePayloadReducer","reduce","_payloadReducers","reducers","toJSON","isRef","isShallow","JSON","stringify","isReactive","toRaw","revive_payload_server_MVtmlZaQpj6ApFmshWfUWl5PehCebzaBf2NuRMiIbms","reducer","defineAsyncComponent","useRequestEvent","event","prerenderRoutes","prerender","paths","appendHeader","map","p","encodeURIComponent","join","OPTIONAL_PARAM_RE","shouldPrerender","processRoutes","routes2","currentPath","routesToPrerender","test","children","includes","plugins","router_GNCWhvtYfLTYRZZ135CdFAEjxdMexN0ixiUYCAN_tpw","splice","layouts","m","LayoutLoader","defineComponent","inheritAttrs","props","String","layoutProps","context","h","slots","nuxtLayoutProps","Boolean","fallback","__nuxt_component_0","injectedRoute","useVueRouterRoute","computed","layout2","unref","layoutRef","expose","done","deferHydration","lastLayout","transitionProps","layoutTransition","previouslyRenderedLayout","Suspense","suspensible","onResolve","nextTick","LayoutProvider","mergeProps","attrs","ref","shouldProvide","isRenderingNewLayout","hasTransition","Function","required","isCurrent","vueRouterRoute","reactiveChildRoute","_key","RouteProvider","vnode","vnodeRef","renderKey","trackRootNodes","previousKey","defineRouteProvider","__nuxt_component_1","transition","keepalive","pageKey","pageRef","RouterView","routeProps","normalizeSlot","Component","slot","slotContent","Fragment","titleTemplate","description","ogDescription","ogImage","twitterCard","_","_push","_parent","_scopeId","_createVNode","_component_NuxtPage","_error","__props","stack","split","line","text","trim","internal","i","is404","message","_Error404","_Error","ErrorTemplate","_ssrRenderComponent","_unref","_mergeProps","_attrs","IslandRenderer","SingleRenderer","callHookWith","abortRender","onErrorCaptured","target","info","catch","hookError","onServerPrefetch","ErrorComponent","createApp","RootComponent","hydratingCount","effectScope","globalName","versions","vue","version","once","_errors","static","active","getCurrentScope","run","called","_asyncDataPromises","_asyncData","_payloadRevivers","serverRendered","public","runtimeConfig","createHooks","contextCaller","$name","createNuxtApp","resolvedPlugins","unresolvedPlugins","parallels","promiseDepth","executePlugin","unresolvedPluginsForThisPlugin","dependsOn","filter","some","has","promise","applyPlugin","all","unexecutedPlugin","size","e","parallel","env","islands","applyPlugins","entry$1"],"sources":["../../../virtual:nuxt:C%3A%2FUsers%2Fsao%2FDocuments%2Fmy-site%2F.nuxt%2Ffetch.mjs","../../../virtual:nuxt:C%3A%2FUsers%2Fsao%2FDocuments%2Fmy-site%2F.nuxt%2Fglobal-polyfills.mjs","../../../virtual:nuxt:C%3A%2FUsers%2Fsao%2FDocuments%2Fmy-site%2F.nuxt%2Fnuxt.config.mjs","../../../node_modules/nuxt/dist/app/nuxt.js","../../../node_modules/nuxt/dist/app/components/injections.js","../../../node_modules/nuxt/dist/app/utils.js","../../../node_modules/nuxt/dist/app/composables/router.js","../../../node_modules/nuxt/dist/app/composables/error.js","../../../node_modules/nuxt/dist/head/runtime/plugins/unhead.js","../../../node_modules/nuxt/dist/pages/runtime/utils.js","../../../virtual:nuxt:C%3A%2FUsers%2Fsao%2FDocuments%2Fmy-site%2F.nuxt%2Froutes.mjs","../../../node_modules/nuxt/dist/app/components/utils.js","../../../node_modules/nuxt/dist/pages/runtime/router.options.js","../../../virtual:nuxt:C%3A%2FUsers%2Fsao%2FDocuments%2Fmy-site%2F.nuxt%2Frouter.options.mjs","../../../virtual:nuxt:C%3A%2FUsers%2Fsao%2FDocuments%2Fmy-site%2F.nuxt%2Fmiddleware.mjs","../../../node_modules/nuxt/dist/pages/runtime/validate.js","../../../middleware/analytics.global.ts","../../../node_modules/nuxt/dist/app/middleware/manifest-route-rule.js","../../../node_modules/nuxt/dist/pages/runtime/plugins/router.js","../../../node_modules/nuxt/dist/app/composables/manifest.js","../../../node_modules/nuxt/dist/head/runtime/composables/v3.js","../../../node_modules/nuxt/dist/app/composables/payload.js","../../../node_modules/nuxt/dist/app/plugins/revive-payload.server.js","../../../node_modules/@nuxt/content/dist/runtime/components/ContentDoc.vue?nuxt_component=async&nuxt_component_name=ContentDoc&nuxt_component_export=default","../../../node_modules/@nuxt/content/dist/runtime/components/ContentList.vue?nuxt_component=async&nuxt_component_name=ContentList&nuxt_component_export=default","../../../node_modules/@nuxt/content/dist/runtime/components/ContentNavigation.vue?nuxt_component=async&nuxt_component_name=ContentNavigation&nuxt_component_export=default","../../../node_modules/@nuxt/content/dist/runtime/components/ContentQuery.vue?nuxt_component=async&nuxt_component_name=ContentQuery&nuxt_component_export=default","../../../node_modules/@nuxt/content/dist/runtime/components/ContentRenderer.vue?nuxt_component=async&nuxt_component_name=ContentRenderer&nuxt_component_export=default","../../../node_modules/@nuxt/content/dist/runtime/components/ContentSlot.vue?nuxt_component=async&nuxt_component_name=ContentSlot&nuxt_component_export=default","../../../node_modules/@nuxt/content/dist/runtime/components/DocumentDrivenEmpty.vue?nuxt_component=async&nuxt_component_name=DocumentDrivenEmpty&nuxt_component_export=default","../../../node_modules/@nuxt/content/dist/runtime/components/DocumentDrivenNotFound.vue?nuxt_component=async&nuxt_component_name=DocumentDrivenNotFound&nuxt_component_export=default","../../../node_modules/nuxt/dist/app/composables/ssr.js","../../../node_modules/nuxt/dist/pages/runtime/plugins/prerender.server.js","../../../virtual:nuxt:C%3A%2FUsers%2Fsao%2FDocuments%2Fmy-site%2F.nuxt%2Fplugins.server.mjs","../../../virtual:nuxt:C%3A%2FUsers%2Fsao%2FDocuments%2Fmy-site%2F.nuxt%2Flayouts.mjs","../../../node_modules/nuxt/dist/app/components/nuxt-layout.js","../../../node_modules/nuxt/dist/app/components/route-provider.js","../../../node_modules/nuxt/dist/pages/runtime/page.js","../../../app.vue","../../../node_modules/nuxt/dist/app/components/nuxt-error-page.vue","../../../node_modules/nuxt/dist/app/components/nuxt-root.vue","../../../node_modules/nuxt/dist/app/entry.js"],"sourcesContent":["import { $fetch } from 'ofetch'\nimport { baseURL } from '#internal/nuxt/paths'\nif (!globalThis.$fetch) {\n  globalThis.$fetch = $fetch.create({\n    baseURL: baseURL()\n  })\n}","\nif (!(\"global\" in globalThis)) {\n  globalThis.global = globalThis;\n}","export const appHead = {\"meta\":[{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"},{\"charset\":\"utf-8\"},{\"name\":\"format-detection\",\"content\":\"telephone=no\"},{\"name\":\"theme-color\",\"content\":\"#3b82f6\"},{\"name\":\"robots\",\"content\":\"index, follow\"},{\"name\":\"author\",\"content\":\"Professional Business Template\"}],\"link\":[{\"rel\":\"icon\",\"type\":\"image/x-icon\",\"href\":\"/favicon.ico\"}],\"style\":[{\"children\":\"/* Critical Above-the-Fold CSS - Inlined for fastest FCP */\\n/* Only essential styles for hero section and initial viewport */\\n\\n/* Reset and base styles */\\n*,\\n*::before,\\n*::after {\\n  box-sizing: border-box;\\n  margin: 0;\\n  padding: 0;\\n}\\n\\nhtml {\\n  font-family: Inter, ui-sans-serif, system-ui, -apple-system, sans-serif;\\n  font-display: swap;\\n  line-height: 1.5;\\n  -webkit-text-size-adjust: 100%;\\n  scroll-behavior: smooth;\\n}\\n\\nbody {\\n  color: #1f2937;\\n  background-color: #ffffff;\\n  font-weight: 400;\\n  min-height: 100vh;\\n}\\n\\n/* Critical layout containers */\\n.min-h-screen {\\n  min-height: 100vh;\\n}\\n\\n.flex {\\n  display: flex;\\n}\\n\\n.flex-col {\\n  flex-direction: column;\\n}\\n\\n.flex-grow {\\n  flex-grow: 1;\\n}\\n\\n.items-center {\\n  align-items: center;\\n}\\n\\n.justify-center {\\n  justify-content: center;\\n}\\n\\n/* Grid system - critical for hero layout */\\n.grid {\\n  display: grid;\\n}\\n\\n.grid-cols-1 {\\n  grid-template-columns: repeat(1, minmax(0, 1fr));\\n}\\n\\n@media (min-width: 1024px) {\\n  .lg\\\\:grid-cols-2 {\\n    grid-template-columns: repeat(2, minmax(0, 1fr));\\n  }\\n}\\n\\n.gap-12 {\\n  gap: 3rem;\\n}\\n\\n/* Hero section critical styles */\\n.hero-bg {\\n  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\\n  color: white;\\n}\\n\\n.section-padding {\\n  padding: 4rem 1rem;\\n}\\n\\n@media (min-width: 640px) {\\n  .section-padding {\\n    padding: 4rem 1.5rem;\\n  }\\n}\\n\\n@media (min-width: 1024px) {\\n  .section-padding {\\n    padding: 4rem 2rem;\\n  }\\n}\\n\\n.container-max {\\n  max-width: 80rem;\\n  margin-left: auto;\\n  margin-right: auto;\\n}\\n\\n/* Typography - critical for hero text */\\n.text-4xl {\\n  font-size: 2.25rem;\\n  line-height: 2.5rem;\\n}\\n\\n@media (min-width: 768px) {\\n  .md\\\\:text-6xl {\\n    font-size: 3.75rem;\\n    line-height: 1;\\n  }\\n}\\n\\n.text-xl {\\n  font-size: 1.25rem;\\n  line-height: 1.75rem;\\n}\\n\\n.font-bold {\\n  font-weight: 700;\\n}\\n\\n.font-semibold {\\n  font-weight: 600;\\n}\\n\\n.font-heading {\\n  font-family: Inter, ui-sans-serif, system-ui, sans-serif;\\n}\\n\\n/* Critical spacing */\\n.mb-6 {\\n  margin-bottom: 1.5rem;\\n}\\n\\n.mb-8 {\\n  margin-bottom: 2rem;\\n}\\n\\n/* Button styles - critical for CTA */\\n.btn {\\n  padding: 0.75rem 1.5rem;\\n  border-radius: 0.5rem;\\n  font-weight: 500;\\n  transition: all 0.2s;\\n  display: inline-block;\\n  text-decoration: none;\\n  border: none;\\n  cursor: pointer;\\n  font-size: 1rem;\\n}\\n\\n.btn:focus {\\n  outline: 2px solid transparent;\\n  outline-offset: 2px;\\n  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);\\n}\\n\\n/* Primary button - hero CTA */\\n.bg-white {\\n  background-color: #ffffff;\\n}\\n\\n.text-primary-600 {\\n  color: #2563eb;\\n}\\n\\n.hover\\\\:bg-blue-50:hover {\\n  background-color: #eff6ff;\\n}\\n\\n/* Outline button */\\n.btn-outline {\\n  border: 2px solid;\\n  background-color: transparent;\\n}\\n\\n.border-white {\\n  border-color: #ffffff;\\n}\\n\\n.text-white {\\n  color: #ffffff;\\n}\\n\\n.hover\\\\:bg-white:hover {\\n  background-color: #ffffff;\\n}\\n\\n.hover\\\\:text-primary-600:hover {\\n  color: #2563eb;\\n}\\n\\n/* Gradient text */\\n.text-gradient {\\n  background: linear-gradient(to right, #2563eb, #1d4ed8);\\n  -webkit-background-clip: text;\\n  background-clip: text;\\n  color: transparent;\\n}\\n\\n.bg-gradient-to-r {\\n  background-image: linear-gradient(to right, var(--tw-gradient-stops));\\n}\\n\\n.from-yellow-400 {\\n  --tw-gradient-from: #fbbf24;\\n  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to, rgba(251, 191, 36, 0));\\n}\\n\\n.to-orange-500 {\\n  --tw-gradient-to: #f97316;\\n}\\n\\n.bg-clip-text {\\n  -webkit-background-clip: text;\\n  background-clip: text;\\n}\\n\\n.text-transparent {\\n  color: transparent;\\n}\\n\\n/* Text colors */\\n.text-blue-100 {\\n  color: #dbeafe;\\n}\\n\\n/* Responsive utilities */\\n@media (min-width: 640px) {\\n  .sm\\\\:flex-row {\\n    flex-direction: row;\\n  }\\n}\\n\\n.gap-4 {\\n  gap: 1rem;\\n}\\n\\n/* Leading for readability */\\n.leading-relaxed {\\n  line-height: 1.625;\\n}\\n\\n/* Text shadow for hero */\\n.text-shadow {\\n  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\\n}\\n\\n/* Hide non-critical content initially */\\n.animate-slide-up,\\n.animate-float {\\n  opacity: 1;\\n  transform: translateY(0);\\n}\\n\\n/* Glass effect for hero visual */\\n.glass-effect {\\n  background: rgba(255, 255, 255, 0.1);\\n  /* Defer expensive blur to post-load for faster LCP */\\n  border: 1px solid rgba(255, 255, 255, 0.2);\\n}\\n\\n/* Apply blur only after we add the 'loaded' class from the performance composable */\\n.glass-effect.loaded {\\n  backdrop-filter: blur(12px);\\n}\\n\\n.w-full {\\n  width: 100%;\\n}\\n\\n.h-96 {\\n  height: 24rem;\\n}\\n\\n.rounded-2xl {\\n  border-radius: 1rem;\\n}\\n\\n.p-8 {\\n  padding: 2rem;\\n}\\n\\n.space-y-4 > * + * {\\n  margin-top: 1rem;\\n}\\n\\n.h-4 {\\n  height: 1rem;\\n}\\n\\n.h-32 {\\n  height: 8rem;\\n}\\n\\n.h-8 {\\n  height: 2rem;\\n}\\n\\n.w-3\\\\/4 {\\n  width: 75%;\\n}\\n\\n.w-1\\\\/2 {\\n  width: 50%;\\n}\\n\\n.w-20 {\\n  width: 5rem;\\n}\\n\\n.w-24 {\\n  width: 6rem;\\n}\\n\\n.rounded {\\n  border-radius: 0.25rem;\\n}\\n\\n.rounded-lg {\\n  border-radius: 0.5rem;\\n}\\n\\n.bg-white\\\\/30 {\\n  background-color: rgba(255, 255, 255, 0.3);\\n}\\n\\n.bg-white\\\\/20 {\\n  background-color: rgba(255, 255, 255, 0.2);\\n}\\n\\n.bg-white\\\\/10 {\\n  background-color: rgba(255, 255, 255, 0.1);\\n}\\n\\n.space-x-2 > * + * {\\n  margin-left: 0.5rem;\\n}\\n\\n.relative {\\n  position: relative;\\n}\\n\"}],\"script\":[],\"noscript\":[],\"charset\":\"utf-8\",\"viewport\":\"width=device-width, initial-scale=1\",\"htmlAttrs\":{\"lang\":\"en\"}}\n\nexport const appBaseURL = \"/\"\n\nexport const appBuildAssetsDir = \"/_nuxt/\"\n\nexport const appCdnURL = \"\"\n\nexport const appLayoutTransition = false\n\nexport const appPageTransition = false\n\nexport const appViewTransition = false\n\nexport const appKeepalive = false\n\nexport const appRootId = \"__nuxt\"\n\nexport const appRootTag = \"div\"\n\nexport const appRootAttrs = {\"id\":\"__nuxt\"}\n\nexport const appTeleportTag = \"div\"\n\nexport const appTeleportId = \"teleports\"\n\nexport const appTeleportAttrs = {\"id\":\"teleports\"}\n\nexport const appSpaLoaderTag = \"div\"\n\nexport const appSpaLoaderAttrs = {\"id\":\"__nuxt-loader\"}\n\nexport const renderJsonPayloads = true\n\nexport const componentIslands = false\n\nexport const payloadExtraction = false\n\nexport const cookieStore = true\n\nexport const appManifest = true\n\nexport const remoteComponentIslands = false\n\nexport const selectiveClient = false\n\nexport const devPagesDir = null\n\nexport const devRootDir = null\n\nexport const devLogs = false\n\nexport const nuxtLinkDefaults = {\"componentName\":\"NuxtLink\",\"prefetch\":true,\"prefetchOn\":{\"visibility\":true}}\n\nexport const asyncDataDefaults = {\"value\":null,\"errorValue\":null,\"deep\":true}\n\nexport const resetAsyncDataToUndefined = true\n\nexport const nuxtDefaultErrorValue = null\n\nexport const fetchDefaults = {}\n\nexport const vueAppRootContainer = '#__nuxt'\n\nexport const viewTransition = false\n\nexport const appId = \"nuxt-app\"\n\nexport const outdatedBuildInterval = 3600000\n\nexport const multiApp = false\n\nexport const chunkErrorEvent = \"vite:preloadError\"\n\nexport const crawlLinks = true\n\nexport const spaLoadingTemplateOutside = false\n\nexport const purgeCachedData = true\n\nexport const granularCachedData = false\n\nexport const pendingWhenIdle = true\n\nexport const alwaysRunFetchOnKeyChange = true","import { effectScope, getCurrentInstance, getCurrentScope, hasInjectionContext, reactive, shallowReactive } from \"vue\";\nimport { createHooks } from \"hookable\";\nimport { getContext } from \"unctx\";\nimport { appId, chunkErrorEvent, multiApp } from \"#build/nuxt.config.mjs\";\nexport function getNuxtAppCtx(id = appId || \"nuxt-app\") {\n  return getContext(id, {\n    asyncContext: !!__NUXT_ASYNC_CONTEXT__ && import.meta.server\n  });\n}\nexport const NuxtPluginIndicator = \"__nuxt_plugin\";\nexport function createNuxtApp(options) {\n  let hydratingCount = 0;\n  const nuxtApp = {\n    _id: options.id || appId || \"nuxt-app\",\n    _scope: effectScope(),\n    provide: void 0,\n    globalName: \"nuxt\",\n    versions: {\n      get nuxt() {\n        return __NUXT_VERSION__;\n      },\n      get vue() {\n        return nuxtApp.vueApp.version;\n      }\n    },\n    payload: shallowReactive({\n      ...options.ssrContext?.payload || {},\n      data: shallowReactive({}),\n      state: reactive({}),\n      once: /* @__PURE__ */ new Set(),\n      _errors: shallowReactive({})\n    }),\n    static: {\n      data: {}\n    },\n    runWithContext(fn) {\n      if (nuxtApp._scope.active && !getCurrentScope()) {\n        return nuxtApp._scope.run(() => callWithNuxt(nuxtApp, fn));\n      }\n      return callWithNuxt(nuxtApp, fn);\n    },\n    isHydrating: import.meta.client,\n    deferHydration() {\n      if (!nuxtApp.isHydrating) {\n        return () => {\n        };\n      }\n      hydratingCount++;\n      let called = false;\n      return () => {\n        if (called) {\n          return;\n        }\n        called = true;\n        hydratingCount--;\n        if (hydratingCount === 0) {\n          nuxtApp.isHydrating = false;\n          return nuxtApp.callHook(\"app:suspense:resolve\");\n        }\n      };\n    },\n    _asyncDataPromises: {},\n    _asyncData: shallowReactive({}),\n    _payloadRevivers: {},\n    ...options\n  };\n  if (import.meta.server) {\n    nuxtApp.payload.serverRendered = true;\n  }\n  if (import.meta.server && nuxtApp.ssrContext) {\n    nuxtApp.payload.path = nuxtApp.ssrContext.url;\n    nuxtApp.ssrContext.nuxt = nuxtApp;\n    nuxtApp.ssrContext.payload = nuxtApp.payload;\n    nuxtApp.ssrContext.config = {\n      public: nuxtApp.ssrContext.runtimeConfig.public,\n      app: nuxtApp.ssrContext.runtimeConfig.app\n    };\n  }\n  if (import.meta.client) {\n    const __NUXT__ = multiApp ? window.__NUXT__?.[nuxtApp._id] : window.__NUXT__;\n    if (__NUXT__) {\n      for (const key in __NUXT__) {\n        switch (key) {\n          case \"data\":\n          case \"state\":\n          case \"_errors\":\n            Object.assign(nuxtApp.payload[key], __NUXT__[key]);\n            break;\n          default:\n            nuxtApp.payload[key] = __NUXT__[key];\n        }\n      }\n    }\n  }\n  nuxtApp.hooks = createHooks();\n  nuxtApp.hook = nuxtApp.hooks.hook;\n  if (import.meta.server) {\n    const contextCaller = async function(hooks, args) {\n      for (const hook of hooks) {\n        await nuxtApp.runWithContext(() => hook(...args));\n      }\n    };\n    nuxtApp.hooks.callHook = (name, ...args) => nuxtApp.hooks.callHookWith(contextCaller, name, ...args);\n  }\n  nuxtApp.callHook = nuxtApp.hooks.callHook;\n  nuxtApp.provide = (name, value) => {\n    const $name = \"$\" + name;\n    defineGetter(nuxtApp, $name, value);\n    defineGetter(nuxtApp.vueApp.config.globalProperties, $name, value);\n  };\n  defineGetter(nuxtApp.vueApp, \"$nuxt\", nuxtApp);\n  defineGetter(nuxtApp.vueApp.config.globalProperties, \"$nuxt\", nuxtApp);\n  if (import.meta.client) {\n    if (chunkErrorEvent) {\n      window.addEventListener(chunkErrorEvent, (event) => {\n        nuxtApp.callHook(\"app:chunkError\", { error: event.payload });\n        if (event.payload.message.includes(\"Unable to preload CSS\")) {\n          event.preventDefault();\n        }\n      });\n    }\n    window.useNuxtApp ||= useNuxtApp;\n    const unreg = nuxtApp.hook(\"app:error\", (...args) => {\n      console.error(\"[nuxt] error caught during app initialization\", ...args);\n    });\n    nuxtApp.hook(\"app:mounted\", unreg);\n  }\n  const runtimeConfig = import.meta.server ? options.ssrContext.runtimeConfig : nuxtApp.payload.config;\n  nuxtApp.provide(\"config\", import.meta.client && import.meta.dev ? wrappedConfig(runtimeConfig) : runtimeConfig);\n  return nuxtApp;\n}\nexport function registerPluginHooks(nuxtApp, plugin) {\n  if (plugin.hooks) {\n    nuxtApp.hooks.addHooks(plugin.hooks);\n  }\n}\nexport async function applyPlugin(nuxtApp, plugin) {\n  if (typeof plugin === \"function\") {\n    const { provide } = await nuxtApp.runWithContext(() => plugin(nuxtApp)) || {};\n    if (provide && typeof provide === \"object\") {\n      for (const key in provide) {\n        nuxtApp.provide(key, provide[key]);\n      }\n    }\n  }\n}\nexport async function applyPlugins(nuxtApp, plugins) {\n  const resolvedPlugins = /* @__PURE__ */ new Set();\n  const unresolvedPlugins = [];\n  const parallels = [];\n  let error = void 0;\n  let promiseDepth = 0;\n  async function executePlugin(plugin) {\n    const unresolvedPluginsForThisPlugin = plugin.dependsOn?.filter((name) => plugins.some((p) => p._name === name) && !resolvedPlugins.has(name)) ?? [];\n    if (unresolvedPluginsForThisPlugin.length > 0) {\n      unresolvedPlugins.push([new Set(unresolvedPluginsForThisPlugin), plugin]);\n    } else {\n      const promise = applyPlugin(nuxtApp, plugin).then(async () => {\n        if (plugin._name) {\n          resolvedPlugins.add(plugin._name);\n          await Promise.all(unresolvedPlugins.map(async ([dependsOn, unexecutedPlugin]) => {\n            if (dependsOn.has(plugin._name)) {\n              dependsOn.delete(plugin._name);\n              if (dependsOn.size === 0) {\n                promiseDepth++;\n                await executePlugin(unexecutedPlugin);\n              }\n            }\n          }));\n        }\n      }).catch((e) => {\n        if (!plugin.parallel && !nuxtApp.payload.error) {\n          throw e;\n        }\n        error ||= e;\n      });\n      if (plugin.parallel) {\n        parallels.push(promise);\n      } else {\n        await promise;\n      }\n    }\n  }\n  for (const plugin of plugins) {\n    if (import.meta.server && nuxtApp.ssrContext?.islandContext && plugin.env?.islands === false) {\n      continue;\n    }\n    registerPluginHooks(nuxtApp, plugin);\n  }\n  for (const plugin of plugins) {\n    if (import.meta.server && nuxtApp.ssrContext?.islandContext && plugin.env?.islands === false) {\n      continue;\n    }\n    await executePlugin(plugin);\n  }\n  await Promise.all(parallels);\n  if (promiseDepth) {\n    for (let i = 0; i < promiseDepth; i++) {\n      await Promise.all(parallels);\n    }\n  }\n  if (error) {\n    throw nuxtApp.payload.error || error;\n  }\n}\n// @__NO_SIDE_EFFECTS__\nexport function defineNuxtPlugin(plugin) {\n  if (typeof plugin === \"function\") {\n    return plugin;\n  }\n  const _name = plugin._name || plugin.name;\n  delete plugin.name;\n  return Object.assign(plugin.setup || (() => {\n  }), plugin, { [NuxtPluginIndicator]: true, _name });\n}\nexport const definePayloadPlugin = defineNuxtPlugin;\nexport function isNuxtPlugin(plugin) {\n  return typeof plugin === \"function\" && NuxtPluginIndicator in plugin;\n}\nexport function callWithNuxt(nuxt, setup, args) {\n  const fn = () => args ? setup(...args) : setup();\n  const nuxtAppCtx = getNuxtAppCtx(nuxt._id);\n  if (import.meta.server) {\n    return nuxt.vueApp.runWithContext(() => nuxtAppCtx.callAsync(nuxt, fn));\n  } else {\n    nuxtAppCtx.set(nuxt);\n    return nuxt.vueApp.runWithContext(fn);\n  }\n}\nexport function tryUseNuxtApp(id) {\n  let nuxtAppInstance;\n  if (hasInjectionContext()) {\n    nuxtAppInstance = getCurrentInstance()?.appContext.app.$nuxt;\n  }\n  nuxtAppInstance ||= getNuxtAppCtx(id).tryUse();\n  return nuxtAppInstance || null;\n}\nexport function useNuxtApp(id) {\n  const nuxtAppInstance = tryUseNuxtApp(id);\n  if (!nuxtAppInstance) {\n    if (import.meta.dev) {\n      throw new Error(\"[nuxt] A composable that requires access to the Nuxt instance was called outside of a plugin, Nuxt hook, Nuxt middleware, or Vue setup function. This is probably not a Nuxt bug. Find out more at `https://nuxt.com/docs/guide/concepts/auto-imports#vue-and-nuxt-composables`.\");\n    } else {\n      throw new Error(\"[nuxt] instance unavailable\");\n    }\n  }\n  return nuxtAppInstance;\n}\n// @__NO_SIDE_EFFECTS__\nexport function useRuntimeConfig(_event) {\n  return useNuxtApp().$config;\n}\nfunction defineGetter(obj, key, val) {\n  Object.defineProperty(obj, key, { get: () => val });\n}\nexport function defineAppConfig(config) {\n  return config;\n}\nconst loggedKeys = /* @__PURE__ */ new Set();\nfunction wrappedConfig(runtimeConfig) {\n  if (!import.meta.dev || import.meta.server) {\n    return runtimeConfig;\n  }\n  const keys = [];\n  for (const key in runtimeConfig) {\n    keys.push(`\\`${key}\\``);\n  }\n  const lastKey = keys.pop();\n  return new Proxy(runtimeConfig, {\n    get(target, p, receiver) {\n      if (typeof p === \"string\" && p !== \"public\" && !(p in target) && !p.startsWith(\"__v\")) {\n        if (!loggedKeys.has(p)) {\n          loggedKeys.add(p);\n          console.warn(`[nuxt] Could not access \\`${p}\\`. The only available runtime config keys on the client side are ${keys.join(\", \")} and ${lastKey}. See https://nuxt.com/docs/guide/going-further/runtime-config for more information.`);\n        }\n      }\n      return Reflect.get(target, p, receiver);\n    }\n  });\n}\n","export const LayoutMetaSymbol = Symbol(\"layout-meta\");\nexport const PageRouteSymbol = Symbol(\"route\");\n","import { captureStackTrace } from \"errx\";\nexport function toArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\nconst distURL = import.meta.url.replace(/\\/app\\/.*$/, \"/\");\nexport function getUserTrace() {\n  if (!import.meta.dev) {\n    return [];\n  }\n  const trace = captureStackTrace();\n  const start = trace.findIndex((entry) => !entry.source.startsWith(distURL));\n  const end = [...trace].reverse().findIndex((entry) => !entry.source.includes(\"node_modules\") && !entry.source.startsWith(distURL));\n  if (start === -1 || end === -1) {\n    return [];\n  }\n  return trace.slice(start, -end).map((i) => ({\n    ...i,\n    source: i.source.replace(/^file:\\/\\//, \"\")\n  }));\n}\nexport function getUserCaller() {\n  if (!import.meta.dev) {\n    return null;\n  }\n  const { source, line, column } = captureStackTrace().find((entry) => !entry.source.startsWith(distURL)) ?? {};\n  if (!source) {\n    return null;\n  }\n  return {\n    source: source.replace(/^file:\\/\\//, \"\"),\n    line,\n    column\n  };\n}\n","import { getCurrentInstance, hasInjectionContext, inject, onScopeDispose } from \"vue\";\nimport { sanitizeStatusCode } from \"h3\";\nimport { hasProtocol, isScriptProtocol, joinURL, parseQuery, parseURL, withQuery } from \"ufo\";\nimport { useNuxtApp, useRuntimeConfig } from \"../nuxt.js\";\nimport { PageRouteSymbol } from \"../components/injections.js\";\nimport { createError, showError } from \"./error.js\";\nimport { getUserTrace } from \"../utils.js\";\nexport const useRouter = () => {\n  return useNuxtApp()?.$router;\n};\nexport const useRoute = () => {\n  if (import.meta.dev && !getCurrentInstance() && isProcessingMiddleware()) {\n    const middleware = useNuxtApp()._processingMiddleware;\n    const trace = getUserTrace().map(({ source, line, column }) => `at ${source}:${line}:${column}`).join(\"\\n\");\n    console.warn(`[nuxt] \\`useRoute\\` was called within middleware${typeof middleware === \"string\" ? ` (\\`${middleware}\\`)` : \"\"}. This may lead to misleading results. Instead, use the (to, from) arguments passed to the middleware to access the new and old routes. Learn more: https://nuxt.com/docs/4.x/guide/directory-structure/app/middleware#accessing-route-in-middleware` + (\"\\n\" + trace));\n  }\n  if (hasInjectionContext()) {\n    return inject(PageRouteSymbol, useNuxtApp()._route);\n  }\n  return useNuxtApp()._route;\n};\nexport const onBeforeRouteLeave = (guard) => {\n  const unsubscribe = useRouter().beforeEach((to, from, next) => {\n    if (to === from) {\n      return;\n    }\n    return guard(to, from, next);\n  });\n  onScopeDispose(unsubscribe);\n};\nexport const onBeforeRouteUpdate = (guard) => {\n  const unsubscribe = useRouter().beforeEach(guard);\n  onScopeDispose(unsubscribe);\n};\n// @__NO_SIDE_EFFECTS__\nexport function defineNuxtRouteMiddleware(middleware) {\n  return middleware;\n}\nexport const addRouteMiddleware = (name, middleware, options = {}) => {\n  const nuxtApp = useNuxtApp();\n  const global = options.global || typeof name !== \"string\";\n  const mw = typeof name !== \"string\" ? name : middleware;\n  if (!mw) {\n    console.warn(\"[nuxt] No route middleware passed to `addRouteMiddleware`.\", name);\n    return;\n  }\n  if (global) {\n    nuxtApp._middleware.global.push(mw);\n  } else {\n    nuxtApp._middleware.named[name] = mw;\n  }\n};\nconst isProcessingMiddleware = () => {\n  try {\n    if (useNuxtApp()._processingMiddleware) {\n      return true;\n    }\n  } catch {\n    return false;\n  }\n  return false;\n};\nconst URL_QUOTE_RE = /\"/g;\nexport const navigateTo = (to, options) => {\n  to ||= \"/\";\n  const toPath = typeof to === \"string\" ? to : \"path\" in to ? resolveRouteObject(to) : useRouter().resolve(to).href;\n  if (import.meta.client && options?.open) {\n    const { target = \"_blank\", windowFeatures = {} } = options.open;\n    const features = [];\n    for (const [feature, value] of Object.entries(windowFeatures)) {\n      if (value !== void 0) {\n        features.push(`${feature.toLowerCase()}=${value}`);\n      }\n    }\n    open(toPath, target, features.join(\", \"));\n    return Promise.resolve();\n  }\n  const isExternalHost = hasProtocol(toPath, { acceptRelative: true });\n  const isExternal = options?.external || isExternalHost;\n  if (isExternal) {\n    if (!options?.external) {\n      throw new Error(\"Navigating to an external URL is not allowed by default. Use `navigateTo(url, { external: true })`.\");\n    }\n    const { protocol } = new URL(toPath, import.meta.client ? window.location.href : \"http://localhost\");\n    if (protocol && isScriptProtocol(protocol)) {\n      throw new Error(`Cannot navigate to a URL with '${protocol}' protocol.`);\n    }\n  }\n  const inMiddleware = isProcessingMiddleware();\n  if (import.meta.client && !isExternal && inMiddleware) {\n    if (options?.replace) {\n      if (typeof to === \"string\") {\n        const { pathname, search, hash } = parseURL(to);\n        return {\n          path: pathname,\n          ...search && { query: parseQuery(search) },\n          ...hash && { hash },\n          replace: true\n        };\n      }\n      return { ...to, replace: true };\n    }\n    return to;\n  }\n  const router = useRouter();\n  const nuxtApp = useNuxtApp();\n  if (import.meta.server) {\n    if (nuxtApp.ssrContext) {\n      const fullPath = typeof to === \"string\" || isExternal ? toPath : router.resolve(to).fullPath || \"/\";\n      const location2 = isExternal ? toPath : joinURL(useRuntimeConfig().app.baseURL, fullPath);\n      const redirect = async function(response) {\n        await nuxtApp.callHook(\"app:redirected\");\n        const encodedLoc = location2.replace(URL_QUOTE_RE, \"%22\");\n        const encodedHeader = encodeURL(location2, isExternalHost);\n        nuxtApp.ssrContext._renderResponse = {\n          statusCode: sanitizeStatusCode(options?.redirectCode || 302, 302),\n          body: `<!DOCTYPE html><html><head><meta http-equiv=\"refresh\" content=\"0; url=${encodedLoc}\"></head></html>`,\n          headers: { location: encodedHeader }\n        };\n        return response;\n      };\n      if (!isExternal && inMiddleware) {\n        router.afterEach((final) => final.fullPath === fullPath ? redirect(false) : void 0);\n        return to;\n      }\n      return redirect(!inMiddleware ? void 0 : (\n        /* abort route navigation */\n        false\n      ));\n    }\n  }\n  if (isExternal) {\n    nuxtApp._scope.stop();\n    if (options?.replace) {\n      location.replace(toPath);\n    } else {\n      location.href = toPath;\n    }\n    if (inMiddleware) {\n      if (!nuxtApp.isHydrating) {\n        return false;\n      }\n      return new Promise(() => {\n      });\n    }\n    return Promise.resolve();\n  }\n  return options?.replace ? router.replace(to) : router.push(to);\n};\nexport const abortNavigation = (err) => {\n  if (import.meta.dev && !isProcessingMiddleware()) {\n    throw new Error(\"abortNavigation() is only usable inside a route middleware handler.\");\n  }\n  if (!err) {\n    return false;\n  }\n  err = createError(err);\n  if (err.fatal) {\n    useNuxtApp().runWithContext(() => showError(err));\n  }\n  throw err;\n};\nexport const setPageLayout = (layout) => {\n  const nuxtApp = useNuxtApp();\n  if (import.meta.server) {\n    if (import.meta.dev && getCurrentInstance() && nuxtApp.payload.state._layout !== layout) {\n      console.warn(\"[warn] [nuxt] `setPageLayout` should not be called to change the layout on the server within a component as this will cause hydration errors.\");\n    }\n    nuxtApp.payload.state._layout = layout;\n  }\n  if (import.meta.dev && nuxtApp.isHydrating && nuxtApp.payload.serverRendered && nuxtApp.payload.state._layout !== layout) {\n    console.warn(\"[warn] [nuxt] `setPageLayout` should not be called to change the layout during hydration as this will cause hydration errors.\");\n  }\n  const inMiddleware = isProcessingMiddleware();\n  if (inMiddleware || import.meta.server || nuxtApp.isHydrating) {\n    const unsubscribe = useRouter().beforeResolve((to) => {\n      to.meta.layout = layout;\n      unsubscribe();\n    });\n  }\n  if (!inMiddleware) {\n    useRoute().meta.layout = layout;\n  }\n};\nexport function resolveRouteObject(to) {\n  return withQuery(to.path || \"\", to.query || {}) + (to.hash || \"\");\n}\nexport function encodeURL(location2, isExternalHost = false) {\n  const url = new URL(location2, \"http://localhost\");\n  if (!isExternalHost) {\n    return url.pathname + url.search + url.hash;\n  }\n  if (location2.startsWith(\"//\")) {\n    return url.toString().replace(url.protocol, \"\");\n  }\n  return url.toString();\n}\n","import { createError as createH3Error } from \"h3\";\nimport { toRef } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { useRouter } from \"./router.js\";\nimport { nuxtDefaultErrorValue } from \"#build/nuxt.config.mjs\";\nexport const NUXT_ERROR_SIGNATURE = \"__nuxt_error\";\nexport const useError = () => toRef(useNuxtApp().payload, \"error\");\nexport const showError = (error) => {\n  const nuxtError = createError(error);\n  try {\n    const nuxtApp = useNuxtApp();\n    const error2 = useError();\n    if (import.meta.client) {\n      nuxtApp.hooks.callHook(\"app:error\", nuxtError);\n    }\n    error2.value ||= nuxtError;\n  } catch {\n    throw nuxtError;\n  }\n  return nuxtError;\n};\nexport const clearError = async (options = {}) => {\n  const nuxtApp = useNuxtApp();\n  const error = useError();\n  nuxtApp.callHook(\"app:error:cleared\", options);\n  if (options.redirect) {\n    await useRouter().replace(options.redirect);\n  }\n  error.value = nuxtDefaultErrorValue;\n};\nexport const isNuxtError = (error) => !!error && typeof error === \"object\" && NUXT_ERROR_SIGNATURE in error;\nexport const createError = (error) => {\n  const nuxtError = createH3Error(error);\n  Object.defineProperty(nuxtError, NUXT_ERROR_SIGNATURE, {\n    value: true,\n    configurable: false,\n    writable: false\n  });\n  return nuxtError;\n};\n","import { createHead as createClientHead, renderDOMHead } from \"@unhead/vue/client\";\nimport { defineNuxtPlugin } from \"#app/nuxt\";\nimport unheadOptions from \"#build/unhead-options.mjs\";\nexport default defineNuxtPlugin({\n  name: \"nuxt:head\",\n  enforce: \"pre\",\n  setup(nuxtApp) {\n    const head = import.meta.server ? nuxtApp.ssrContext.head : createClientHead(unheadOptions);\n    nuxtApp.vueApp.use(head);\n    if (import.meta.client) {\n      let pauseDOMUpdates = true;\n      const syncHead = async () => {\n        pauseDOMUpdates = false;\n        await renderDOMHead(head);\n      };\n      head.hooks.hook(\"dom:beforeRender\", (context) => {\n        context.shouldRender = !pauseDOMUpdates;\n      });\n      nuxtApp.hooks.hook(\"page:start\", () => {\n        pauseDOMUpdates = true;\n      });\n      nuxtApp.hooks.hook(\"page:finish\", () => {\n        if (!nuxtApp.isHydrating) {\n          syncHead();\n        }\n      });\n      nuxtApp.hooks.hook(\"app:error\", syncHead);\n      nuxtApp.hooks.hook(\"app:suspense:resolve\", syncHead);\n    }\n  }\n});\n","import { KeepAlive, h } from \"vue\";\nconst ROUTE_KEY_PARENTHESES_RE = /(:\\w+)\\([^)]+\\)/g;\nconst ROUTE_KEY_SYMBOLS_RE = /(:\\w+)[?+*]/g;\nconst ROUTE_KEY_NORMAL_RE = /:\\w+/g;\nconst interpolatePath = (route, match) => {\n  return match.path.replace(ROUTE_KEY_PARENTHESES_RE, \"$1\").replace(ROUTE_KEY_SYMBOLS_RE, \"$1\").replace(ROUTE_KEY_NORMAL_RE, (r) => route.params[r.slice(1)]?.toString() || \"\");\n};\nexport const generateRouteKey = (routeProps, override) => {\n  const matchedRoute = routeProps.route.matched.find((m) => m.components?.default === routeProps.Component.type);\n  const source = override ?? matchedRoute?.meta.key ?? (matchedRoute && interpolatePath(routeProps.route, matchedRoute));\n  return typeof source === \"function\" ? source(routeProps.route) : source;\n};\nexport const wrapInKeepAlive = (props, children) => {\n  return { default: () => import.meta.client && props ? h(KeepAlive, props === true ? {} : props, children) : children };\n};\nexport function toArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n","\nif (import.meta.hot) {\n  import.meta.hot.accept((mod) => {\n    const router = import.meta.hot.data.router\n    const generateRoutes = import.meta.hot.data.generateRoutes\n    if (!router || !generateRoutes) {\n      import.meta.hot.invalidate('[nuxt] Cannot replace routes because there is no active router. Reloading.')\n      return\n    }\n    router.clearRoutes()\n    const routes = generateRoutes(mod.default || mod)\n    function addRoutes (routes) {\n      for (const route of routes) {\n        router.addRoute(route)\n      }\n      router.replace(router.currentRoute.value.fullPath)\n    }\n    if (routes && 'then' in routes) {\n      routes.then(addRoutes)\n    } else {\n      addRoutes(routes)\n    }\n  })\n}\n\nexport function handleHotUpdate(_router, _generateRoutes) {\n  if (import.meta.hot) {\n    import.meta.hot.data ||= {}\n    import.meta.hot.data.router = _router\n    import.meta.hot.data.generateRoutes = _generateRoutes\n  }\n}\nimport { default as aboutbuV0e6SvkJwM1fOODYFLsJu7DbCOmAaXteBg8fe7nEUMeta } from \"C:/Users/sao/Documents/my-site/pages/about.vue?macro=true\";\nimport { default as indexi7I4gu9wb6UZJCe3jKqcufsGfl5CFU3s5lZ74qNLfLkMeta } from \"C:/Users/sao/Documents/my-site/pages/index.vue?macro=true\";\nimport { default as termsMUhvg535ijko6B9_JvFWuUMMxB5sJhv7tl4pw3VpCzQMeta } from \"C:/Users/sao/Documents/my-site/pages/terms.vue?macro=true\";\nimport { default as contactzCULB0QWj6O1LUblvCwnwClwJIrvYcTfM5h0Zb7ALjkMeta } from \"C:/Users/sao/Documents/my-site/pages/contact.vue?macro=true\";\nimport { default as privacylrcA5yPwpmV5J7afimDE_45t7chF5WOB7uIqDI8itS6A4Meta } from \"C:/Users/sao/Documents/my-site/pages/privacy.vue?macro=true\";\nimport { default as services4CqyDOR1jnj1opZDIRhkw_45kylcoPUIl26B91KuVu8noMeta } from \"C:/Users/sao/Documents/my-site/pages/services.vue?macro=true\";\nimport { default as portfoliooReNHyElaBRwLbGDGi50xWehQQiJtz6K2pp_45mUBFmB0Meta } from \"C:/Users/sao/Documents/my-site/pages/portfolio.vue?macro=true\";\nimport { default as indexsR0mILws1Os_MFTpOIn9Hlv1PgL5L_45uG3Q8qfoFsI1YMeta } from \"C:/Users/sao/Documents/my-site/pages/blog/index.vue?macro=true\";\nimport { default as _91slug_93InJBUhnOUh0s4DCI7K5GP2qchwAUpaFW5iWHbsgMupwMeta } from \"C:/Users/sao/Documents/my-site/pages/blog/[slug].vue?macro=true\";\nexport default [\n  {\n    name: \"about\",\n    path: \"/about\",\n    component: () => import(\"C:/Users/sao/Documents/my-site/pages/about.vue\")\n  },\n  {\n    name: \"index\",\n    path: \"/\",\n    component: () => import(\"C:/Users/sao/Documents/my-site/pages/index.vue\")\n  },\n  {\n    name: \"terms\",\n    path: \"/terms\",\n    component: () => import(\"C:/Users/sao/Documents/my-site/pages/terms.vue\")\n  },\n  {\n    name: \"contact\",\n    path: \"/contact\",\n    component: () => import(\"C:/Users/sao/Documents/my-site/pages/contact.vue\")\n  },\n  {\n    name: \"privacy\",\n    path: \"/privacy\",\n    component: () => import(\"C:/Users/sao/Documents/my-site/pages/privacy.vue\")\n  },\n  {\n    name: \"services\",\n    path: \"/services\",\n    component: () => import(\"C:/Users/sao/Documents/my-site/pages/services.vue\")\n  },\n  {\n    name: \"portfolio\",\n    path: \"/portfolio\",\n    component: () => import(\"C:/Users/sao/Documents/my-site/pages/portfolio.vue\")\n  },\n  {\n    name: \"blog\",\n    path: \"/blog\",\n    component: () => import(\"C:/Users/sao/Documents/my-site/pages/blog/index.vue\")\n  },\n  {\n    name: \"blog-slug\",\n    path: \"/blog/:slug()\",\n    component: () => import(\"C:/Users/sao/Documents/my-site/pages/blog/[slug].vue\")\n  }\n]","import { Transition, createStaticVNode, h } from \"vue\";\nimport { isString, isPromise, isArray, isObject } from \"@vue/shared\";\nimport { START_LOCATION } from \"#build/pages\";\nexport const _wrapInTransition = (props, children) => {\n  return { default: () => import.meta.client && props ? h(Transition, props === true ? {} : props, children) : children.default?.() };\n};\nconst ROUTE_KEY_PARENTHESES_RE = /(:\\w+)\\([^)]+\\)/g;\nconst ROUTE_KEY_SYMBOLS_RE = /(:\\w+)[?+*]/g;\nconst ROUTE_KEY_NORMAL_RE = /:\\w+/g;\nfunction generateRouteKey(route) {\n  const source = route?.meta.key ?? route.path.replace(ROUTE_KEY_PARENTHESES_RE, \"$1\").replace(ROUTE_KEY_SYMBOLS_RE, \"$1\").replace(ROUTE_KEY_NORMAL_RE, (r) => route.params[r.slice(1)]?.toString() || \"\");\n  return typeof source === \"function\" ? source(route) : source;\n}\nexport function isChangingPage(to, from) {\n  if (to === from || from === START_LOCATION) {\n    return false;\n  }\n  if (generateRouteKey(to) !== generateRouteKey(from)) {\n    return true;\n  }\n  const areComponentsSame = to.matched.every(\n    (comp, index) => comp.components && comp.components.default === from.matched[index]?.components?.default\n  );\n  if (areComponentsSame) {\n    return false;\n  }\n  return true;\n}\nexport function createBuffer() {\n  let appendable = false;\n  const buffer = [];\n  return {\n    getBuffer() {\n      return buffer;\n    },\n    push(item) {\n      const isStringItem = isString(item);\n      if (appendable && isStringItem) {\n        buffer[buffer.length - 1] += item;\n      } else {\n        buffer.push(item);\n      }\n      appendable = isStringItem;\n      if (isPromise(item) || isArray(item) && item.hasAsync) {\n        buffer.hasAsync = true;\n      }\n    }\n  };\n}\nexport function vforToArray(source) {\n  if (isArray(source)) {\n    return source;\n  } else if (isString(source)) {\n    return source.split(\"\");\n  } else if (typeof source === \"number\") {\n    if (import.meta.dev && !Number.isInteger(source)) {\n      console.warn(`The v-for range expect an integer value but got ${source}.`);\n    }\n    const array = [];\n    for (let i = 0; i < source; i++) {\n      array[i] = i;\n    }\n    return array;\n  } else if (isObject(source)) {\n    if (source[Symbol.iterator]) {\n      return Array.from(\n        source,\n        (item) => item\n      );\n    } else {\n      const keys = Object.keys(source);\n      const array = new Array(keys.length);\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const key = keys[i];\n        array[i] = source[key];\n      }\n      return array;\n    }\n  }\n  return [];\n}\nexport function getFragmentHTML(element, withoutSlots = false) {\n  if (element) {\n    if (element.nodeName === \"#comment\" && element.nodeValue === \"[\") {\n      return getFragmentChildren(element, [], withoutSlots);\n    }\n    if (withoutSlots) {\n      const clone = element.cloneNode(true);\n      clone.querySelectorAll(\"[data-island-slot]\").forEach((n) => {\n        n.innerHTML = \"\";\n      });\n      return [clone.outerHTML];\n    }\n    return [element.outerHTML];\n  }\n}\nfunction getFragmentChildren(element, blocks = [], withoutSlots = false) {\n  if (element && element.nodeName) {\n    if (isEndFragment(element)) {\n      return blocks;\n    } else if (!isStartFragment(element)) {\n      const clone = element.cloneNode(true);\n      if (withoutSlots) {\n        clone.querySelectorAll?.(\"[data-island-slot]\").forEach((n) => {\n          n.innerHTML = \"\";\n        });\n      }\n      blocks.push(clone.outerHTML);\n    }\n    getFragmentChildren(element.nextSibling, blocks, withoutSlots);\n  }\n  return blocks;\n}\nexport function elToStaticVNode(el, staticNodeFallback) {\n  const fragment = el ? getFragmentHTML(el) : staticNodeFallback ? [staticNodeFallback] : void 0;\n  if (fragment) {\n    return createStaticVNode(fragment.join(\"\"), fragment.length);\n  }\n  return h(\"div\");\n}\nexport function isStartFragment(element) {\n  return element.nodeName === \"#comment\" && element.nodeValue === \"[\";\n}\nexport function isEndFragment(element) {\n  return element.nodeName === \"#comment\" && element.nodeValue === \"]\";\n}\n","import { START_LOCATION } from \"vue-router\";\nimport { useNuxtApp } from \"#app/nuxt\";\nimport { isChangingPage } from \"#app/components/utils\";\nimport { useRouter } from \"#app/composables/router\";\nexport default {\n  scrollBehavior(to, from, savedPosition) {\n    const nuxtApp = useNuxtApp();\n    const hashScrollBehaviour = useRouter().options?.scrollBehaviorType ?? \"auto\";\n    if (to.path === from.path) {\n      if (from.hash && !to.hash) {\n        return { left: 0, top: 0 };\n      }\n      if (to.hash) {\n        return { el: to.hash, top: _getHashElementScrollMarginTop(to.hash), behavior: hashScrollBehaviour };\n      }\n      return false;\n    }\n    const routeAllowsScrollToTop = typeof to.meta.scrollToTop === \"function\" ? to.meta.scrollToTop(to, from) : to.meta.scrollToTop;\n    if (routeAllowsScrollToTop === false) {\n      return false;\n    }\n    const hookToWait = nuxtApp._runningTransition ? \"page:transition:finish\" : \"page:loading:end\";\n    return new Promise((resolve) => {\n      if (from === START_LOCATION) {\n        resolve(_calculatePosition(to, from, savedPosition, hashScrollBehaviour));\n        return;\n      }\n      nuxtApp.hooks.hookOnce(hookToWait, () => {\n        requestAnimationFrame(() => resolve(_calculatePosition(to, from, savedPosition, hashScrollBehaviour)));\n      });\n    });\n  }\n};\nfunction _getHashElementScrollMarginTop(selector) {\n  try {\n    const elem = document.querySelector(selector);\n    if (elem) {\n      return (Number.parseFloat(getComputedStyle(elem).scrollMarginTop) || 0) + (Number.parseFloat(getComputedStyle(document.documentElement).scrollPaddingTop) || 0);\n    }\n  } catch {\n  }\n  return 0;\n}\nfunction _calculatePosition(to, from, savedPosition, defaultHashScrollBehaviour) {\n  if (savedPosition) {\n    return savedPosition;\n  }\n  const isPageNavigation = isChangingPage(to, from);\n  if (to.hash) {\n    return {\n      el: to.hash,\n      top: _getHashElementScrollMarginTop(to.hash),\n      behavior: isPageNavigation ? defaultHashScrollBehaviour : \"instant\"\n    };\n  }\n  return {\n    left: 0,\n    top: 0\n  };\n}\n","import routerOptions0 from \"C:/Users/sao/Documents/my-site/node_modules/nuxt/dist/pages/runtime/router.options.js\";\nconst configRouterOptions = {\n  hashMode: false,\n  scrollBehaviorType: \"auto\"\n}\nexport const hashMode = false\nexport default {\n...configRouterOptions,\n...routerOptions0,\n}","import validate from \"C:/Users/sao/Documents/my-site/node_modules/nuxt/dist/pages/runtime/validate.js\";\nimport analytics_45global from \"C:/Users/sao/Documents/my-site/middleware/analytics.global.ts\";\nimport manifest_45route_45rule from \"C:/Users/sao/Documents/my-site/node_modules/nuxt/dist/app/middleware/manifest-route-rule.js\";\nexport const globalMiddleware = [\n  validate,\n  analytics_45global,\n  manifest_45route_45rule\n]\nexport const namedMiddleware = {}","import { createError } from \"#app/composables/error\";\nimport { defineNuxtRouteMiddleware } from \"#app/composables/router\";\nexport default defineNuxtRouteMiddleware(async (to, from) => {\n  if (!to.meta?.validate) {\n    return;\n  }\n  const result = await Promise.resolve(to.meta.validate(to));\n  if (result === true) {\n    return;\n  }\n  const error = createError({\n    fatal: import.meta.client,\n    statusCode: result && result.statusCode || 404,\n    statusMessage: result && result.statusMessage || `Page Not Found: ${to.fullPath}`,\n    data: {\n      path: to.fullPath\n    }\n  });\n  if (typeof window !== \"undefined\") {\n    window.history.pushState({}, \"\", from.fullPath);\n  }\n  return error;\n});\n","/**\n * Global analytics middleware for tracking page views\n */\n\nexport default defineNuxtRouteMiddleware((to) => {\n  // Only run on client side\n  if (process.client) {\n    const config = useRuntimeConfig()\n    const gaId = config.public.googleAnalytics\n\n    // Google Analytics 4 tracking\n    if (gaId && typeof window !== 'undefined' && (window as any).gtag) {\n      (window as any).gtag('config', gaId, {\n        page_title: document.title,\n        page_location: window.location.href,\n        page_path: to.path\n      })\n    }\n\n    // Custom analytics tracking\n    const trackPageView = () => {\n      // Add custom tracking logic here\n      console.log(`Page view: ${to.path}`)\n    }\n\n    // Track page view with a small delay to ensure page is loaded\n    setTimeout(trackPageView, 100)\n  }\n})\n","import { hasProtocol } from \"ufo\";\nimport { defineNuxtRouteMiddleware } from \"../composables/router.js\";\nimport { getRouteRules } from \"../composables/manifest.js\";\nexport default defineNuxtRouteMiddleware(async (to) => {\n  if (import.meta.server || import.meta.test) {\n    return;\n  }\n  const rules = await getRouteRules({ path: to.path });\n  if (rules.redirect) {\n    if (hasProtocol(rules.redirect, { acceptRelative: true })) {\n      window.location.href = rules.redirect;\n      return false;\n    }\n    return rules.redirect;\n  }\n});\n","import { isReadonly, reactive, shallowReactive, shallowRef } from \"vue\";\nimport { START_LOCATION, createMemoryHistory, createRouter, createWebHashHistory, createWebHistory } from \"vue-router\";\nimport { isSamePath, withoutBase } from \"ufo\";\nimport { toArray } from \"../utils.js\";\nimport { getRouteRules } from \"#app/composables/manifest\";\nimport { defineNuxtPlugin, useRuntimeConfig } from \"#app/nuxt\";\nimport { clearError, createError, isNuxtError, showError, useError } from \"#app/composables/error\";\nimport { navigateTo } from \"#app/composables/router\";\nimport { appManifest as isAppManifestEnabled } from \"#build/nuxt.config.mjs\";\nimport _routes, { handleHotUpdate } from \"#build/routes\";\nimport routerOptions, { hashMode } from \"#build/router.options\";\nimport { globalMiddleware, namedMiddleware } from \"#build/middleware\";\nfunction createCurrentLocation(base, location, renderedPath) {\n  const { pathname, search, hash } = location;\n  const hashPos = base.indexOf(\"#\");\n  if (hashPos > -1) {\n    const slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;\n    let pathFromHash = hash.slice(slicePos);\n    if (pathFromHash[0] !== \"/\") {\n      pathFromHash = \"/\" + pathFromHash;\n    }\n    return withoutBase(pathFromHash, \"\");\n  }\n  const displayedPath = withoutBase(pathname, base);\n  const path = !renderedPath || isSamePath(displayedPath, renderedPath) ? displayedPath : renderedPath;\n  return path + (path.includes(\"?\") ? \"\" : search) + hash;\n}\nconst plugin = defineNuxtPlugin({\n  name: \"nuxt:router\",\n  enforce: \"pre\",\n  async setup(nuxtApp) {\n    let routerBase = useRuntimeConfig().app.baseURL;\n    if (hashMode && !routerBase.includes(\"#\")) {\n      routerBase += \"#\";\n    }\n    const history = routerOptions.history?.(routerBase) ?? (import.meta.client ? hashMode ? createWebHashHistory(routerBase) : createWebHistory(routerBase) : createMemoryHistory(routerBase));\n    const routes = routerOptions.routes ? await routerOptions.routes(_routes) ?? _routes : _routes;\n    let startPosition;\n    const router = createRouter({\n      ...routerOptions,\n      scrollBehavior: (to, from, savedPosition) => {\n        if (from === START_LOCATION) {\n          startPosition = savedPosition;\n          return;\n        }\n        if (routerOptions.scrollBehavior) {\n          router.options.scrollBehavior = routerOptions.scrollBehavior;\n          if (\"scrollRestoration\" in window.history) {\n            const unsub = router.beforeEach(() => {\n              unsub();\n              window.history.scrollRestoration = \"manual\";\n            });\n          }\n          return routerOptions.scrollBehavior(to, START_LOCATION, startPosition || savedPosition);\n        }\n      },\n      history,\n      routes\n    });\n    if (import.meta.hot) {\n      handleHotUpdate(router, routerOptions.routes ? routerOptions.routes : (routes2) => routes2);\n    }\n    if (import.meta.client && \"scrollRestoration\" in window.history) {\n      window.history.scrollRestoration = \"auto\";\n    }\n    nuxtApp.vueApp.use(router);\n    const previousRoute = shallowRef(router.currentRoute.value);\n    router.afterEach((_to, from) => {\n      previousRoute.value = from;\n    });\n    Object.defineProperty(nuxtApp.vueApp.config.globalProperties, \"previousRoute\", {\n      get: () => previousRoute.value\n    });\n    const initialURL = import.meta.server ? nuxtApp.ssrContext.url : createCurrentLocation(routerBase, window.location, nuxtApp.payload.path);\n    const _route = shallowRef(router.currentRoute.value);\n    const syncCurrentRoute = () => {\n      _route.value = router.currentRoute.value;\n    };\n    nuxtApp.hook(\"page:finish\", syncCurrentRoute);\n    router.afterEach((to, from) => {\n      if (to.matched[to.matched.length - 1]?.components?.default === from.matched[from.matched.length - 1]?.components?.default) {\n        syncCurrentRoute();\n      }\n    });\n    const route = {};\n    for (const key in _route.value) {\n      Object.defineProperty(route, key, {\n        get: () => _route.value[key],\n        enumerable: true\n      });\n    }\n    nuxtApp._route = shallowReactive(route);\n    nuxtApp._middleware ||= {\n      global: [],\n      named: {}\n    };\n    const error = useError();\n    if (import.meta.client || !nuxtApp.ssrContext?.islandContext) {\n      router.afterEach(async (to, _from, failure) => {\n        delete nuxtApp._processingMiddleware;\n        if (import.meta.client && !nuxtApp.isHydrating && error.value) {\n          await nuxtApp.runWithContext(clearError);\n        }\n        if (failure) {\n          await nuxtApp.callHook(\"page:loading:end\");\n        }\n        if (import.meta.server && failure?.type === 4) {\n          return;\n        }\n        if (import.meta.server && to.redirectedFrom && to.fullPath !== initialURL) {\n          await nuxtApp.runWithContext(() => navigateTo(to.fullPath || \"/\"));\n        }\n      });\n    }\n    try {\n      if (import.meta.server) {\n        await router.push(initialURL);\n      }\n      await router.isReady();\n    } catch (error2) {\n      await nuxtApp.runWithContext(() => showError(error2));\n    }\n    const resolvedInitialRoute = import.meta.client && initialURL !== router.currentRoute.value.fullPath ? router.resolve(initialURL) : router.currentRoute.value;\n    syncCurrentRoute();\n    if (import.meta.server && nuxtApp.ssrContext?.islandContext) {\n      return { provide: { router } };\n    }\n    const initialLayout = nuxtApp.payload.state._layout;\n    router.beforeEach(async (to, from) => {\n      await nuxtApp.callHook(\"page:loading:start\");\n      to.meta = reactive(to.meta);\n      if (nuxtApp.isHydrating && initialLayout && !isReadonly(to.meta.layout)) {\n        to.meta.layout = initialLayout;\n      }\n      nuxtApp._processingMiddleware = true;\n      if (import.meta.client || !nuxtApp.ssrContext?.islandContext) {\n        const middlewareEntries = /* @__PURE__ */ new Set([...globalMiddleware, ...nuxtApp._middleware.global]);\n        for (const component of to.matched) {\n          const componentMiddleware = component.meta.middleware;\n          if (!componentMiddleware) {\n            continue;\n          }\n          for (const entry of toArray(componentMiddleware)) {\n            middlewareEntries.add(entry);\n          }\n        }\n        if (isAppManifestEnabled) {\n          const routeRules = await nuxtApp.runWithContext(() => getRouteRules({ path: to.path }));\n          if (routeRules.appMiddleware) {\n            for (const key in routeRules.appMiddleware) {\n              if (routeRules.appMiddleware[key]) {\n                middlewareEntries.add(key);\n              } else {\n                middlewareEntries.delete(key);\n              }\n            }\n          }\n        }\n        for (const entry of middlewareEntries) {\n          const middleware = typeof entry === \"string\" ? nuxtApp._middleware.named[entry] || await namedMiddleware[entry]?.().then((r) => r.default || r) : entry;\n          if (!middleware) {\n            if (import.meta.dev) {\n              throw new Error(`Unknown route middleware: '${entry}'. Valid middleware: ${Object.keys(namedMiddleware).map((mw) => `'${mw}'`).join(\", \")}.`);\n            }\n            throw new Error(`Unknown route middleware: '${entry}'.`);\n          }\n          try {\n            if (import.meta.dev) {\n              nuxtApp._processingMiddleware = middleware._path || (typeof entry === \"string\" ? entry : true);\n            }\n            const result = await nuxtApp.runWithContext(() => middleware(to, from));\n            if (import.meta.server || !nuxtApp.payload.serverRendered && nuxtApp.isHydrating) {\n              if (result === false || result instanceof Error) {\n                const error2 = result || createError({\n                  statusCode: 404,\n                  statusMessage: `Page Not Found: ${initialURL}`\n                });\n                await nuxtApp.runWithContext(() => showError(error2));\n                return false;\n              }\n            }\n            if (result === true) {\n              continue;\n            }\n            if (result === false) {\n              return result;\n            }\n            if (result) {\n              if (isNuxtError(result) && result.fatal) {\n                await nuxtApp.runWithContext(() => showError(result));\n              }\n              return result;\n            }\n          } catch (err) {\n            const error2 = createError(err);\n            if (error2.fatal) {\n              await nuxtApp.runWithContext(() => showError(error2));\n            }\n            return error2;\n          }\n        }\n      }\n    });\n    router.onError(async () => {\n      delete nuxtApp._processingMiddleware;\n      await nuxtApp.callHook(\"page:loading:end\");\n    });\n    router.afterEach((to) => {\n      if (to.matched.length === 0) {\n        return nuxtApp.runWithContext(() => showError(createError({\n          statusCode: 404,\n          fatal: false,\n          statusMessage: `Page not found: ${to.fullPath}`,\n          data: {\n            path: to.fullPath\n          }\n        })));\n      }\n    });\n    nuxtApp.hooks.hookOnce(\"app:created\", async () => {\n      try {\n        if (\"name\" in resolvedInitialRoute) {\n          resolvedInitialRoute.name = void 0;\n        }\n        await router.replace({\n          ...resolvedInitialRoute,\n          force: true\n        });\n        router.options.scrollBehavior = routerOptions.scrollBehavior;\n      } catch (error2) {\n        await nuxtApp.runWithContext(() => showError(error2));\n      }\n    });\n    return { provide: { router } };\n  }\n});\nexport default plugin;\n","import { createMatcherFromExport, createRouter as createRadixRouter, toRouteMatcher } from \"radix3\";\nimport { defu } from \"defu\";\nimport { useNuxtApp, useRuntimeConfig } from \"../nuxt.js\";\nimport { appManifest as isAppManifestEnabled } from \"#build/nuxt.config.mjs\";\nimport { buildAssetsURL } from \"#internal/nuxt/paths\";\nlet manifest;\nlet matcher;\nfunction fetchManifest() {\n  if (!isAppManifestEnabled) {\n    throw new Error(\"[nuxt] app manifest should be enabled with `experimental.appManifest`\");\n  }\n  if (import.meta.server) {\n    manifest = import(\"#app-manifest\");\n  } else {\n    manifest = $fetch(buildAssetsURL(`builds/meta/${useRuntimeConfig().app.buildId}.json`), {\n      responseType: \"json\"\n    });\n  }\n  manifest.then((m) => {\n    matcher = createMatcherFromExport(m.matcher);\n  }).catch((e) => {\n    console.error(\"[nuxt] Error fetching app manifest.\", e);\n  });\n  return manifest;\n}\nexport function getAppManifest() {\n  if (!isAppManifestEnabled) {\n    throw new Error(\"[nuxt] app manifest should be enabled with `experimental.appManifest`\");\n  }\n  if (import.meta.server) {\n    useNuxtApp().ssrContext._preloadManifest = true;\n  }\n  return manifest || fetchManifest();\n}\nexport async function getRouteRules(arg) {\n  const path = typeof arg === \"string\" ? arg : arg.path;\n  if (import.meta.server) {\n    useNuxtApp().ssrContext._preloadManifest = true;\n    const _routeRulesMatcher = toRouteMatcher(\n      createRadixRouter({ routes: useRuntimeConfig().nitro.routeRules })\n    );\n    return defu({}, ..._routeRulesMatcher.matchAll(path).reverse());\n  }\n  await getAppManifest();\n  if (!matcher) {\n    console.error(\"[nuxt] Error creating app manifest matcher.\", matcher);\n    return {};\n  }\n  try {\n    return defu({}, ...matcher.matchAll(path).reverse());\n  } catch (e) {\n    console.error(\"[nuxt] Error matching route rules.\", e);\n    return {};\n  }\n}\n","import { hasInjectionContext, inject } from \"vue\";\nimport {\n  useHead as headCore,\n  useHeadSafe as headSafe,\n  headSymbol,\n  useSeoMeta as seoMeta,\n  useServerHead as serverHead,\n  useServerHeadSafe as serverHeadSafe,\n  useServerSeoMeta as serverSeoMeta\n} from \"@unhead/vue\";\nimport { tryUseNuxtApp } from \"#app/nuxt\";\nexport function injectHead(nuxtApp) {\n  const nuxt = nuxtApp || tryUseNuxtApp();\n  return nuxt?.ssrContext?.head || nuxt?.runWithContext(() => {\n    if (hasInjectionContext()) {\n      return inject(headSymbol);\n    }\n  });\n}\nexport function useHead(input, options = {}) {\n  const head = injectHead(options.nuxt);\n  if (head) {\n    return headCore(input, { head, ...options });\n  }\n}\nexport function useHeadSafe(input, options = {}) {\n  const head = injectHead(options.nuxt);\n  if (head) {\n    return headSafe(input, { head, ...options });\n  }\n}\nexport function useSeoMeta(input, options = {}) {\n  const head = injectHead(options.nuxt);\n  if (head) {\n    return seoMeta(input, { head, ...options });\n  }\n}\nexport function useServerHead(input, options = {}) {\n  const head = injectHead(options.nuxt);\n  if (head) {\n    return serverHead(input, { head, ...options });\n  }\n}\nexport function useServerHeadSafe(input, options = {}) {\n  const head = injectHead(options.nuxt);\n  if (head) {\n    return serverHeadSafe(input, { head, ...options });\n  }\n}\nexport function useServerSeoMeta(input, options = {}) {\n  const head = injectHead(options.nuxt);\n  if (head) {\n    return serverSeoMeta(input, { head, ...options });\n  }\n}\n","import { hasProtocol, joinURL, withoutTrailingSlash } from \"ufo\";\nimport { parse } from \"devalue\";\nimport { getCurrentInstance, onServerPrefetch, reactive } from \"vue\";\nimport { useNuxtApp, useRuntimeConfig } from \"../nuxt.js\";\nimport { useHead } from \"./head.js\";\nimport { useRoute } from \"./router.js\";\nimport { getAppManifest, getRouteRules } from \"./manifest.js\";\nimport { appId, appManifest, multiApp, payloadExtraction, renderJsonPayloads } from \"#build/nuxt.config.mjs\";\nexport async function loadPayload(url, opts = {}) {\n  if (import.meta.server || !payloadExtraction) {\n    return null;\n  }\n  const shouldLoadPayload = await isPrerendered(url);\n  if (!shouldLoadPayload) {\n    return null;\n  }\n  const payloadURL = await _getPayloadURL(url, opts);\n  return await _importPayload(payloadURL) || null;\n}\nlet linkRelType;\nfunction detectLinkRelType() {\n  if (import.meta.server) {\n    return \"preload\";\n  }\n  if (linkRelType) {\n    return linkRelType;\n  }\n  const relList = document.createElement(\"link\").relList;\n  linkRelType = relList && relList.supports && relList.supports(\"prefetch\") ? \"prefetch\" : \"preload\";\n  return linkRelType;\n}\nexport function preloadPayload(url, opts = {}) {\n  const nuxtApp = useNuxtApp();\n  const promise = _getPayloadURL(url, opts).then((payloadURL) => {\n    const link = renderJsonPayloads ? { rel: detectLinkRelType(), as: \"fetch\", crossorigin: \"anonymous\", href: payloadURL } : { rel: \"modulepreload\", crossorigin: \"\", href: payloadURL };\n    if (import.meta.server) {\n      nuxtApp.runWithContext(() => useHead({ link: [link] }));\n    } else {\n      const linkEl = document.createElement(\"link\");\n      for (const key of Object.keys(link)) {\n        linkEl[key === \"crossorigin\" ? \"crossOrigin\" : key] = link[key];\n      }\n      document.head.appendChild(linkEl);\n      return new Promise((resolve, reject) => {\n        linkEl.addEventListener(\"load\", () => resolve());\n        linkEl.addEventListener(\"error\", () => reject());\n      });\n    }\n  });\n  if (import.meta.server) {\n    onServerPrefetch(() => promise);\n  }\n  return promise;\n}\nconst filename = renderJsonPayloads ? \"_payload.json\" : \"_payload.js\";\nasync function _getPayloadURL(url, opts = {}) {\n  const u = new URL(url, \"http://localhost\");\n  if (u.host !== \"localhost\" || hasProtocol(u.pathname, { acceptRelative: true })) {\n    throw new Error(\"Payload URL must not include hostname: \" + url);\n  }\n  const config = useRuntimeConfig();\n  const hash = opts.hash || (opts.fresh ? Date.now() : config.app.buildId);\n  const cdnURL = config.app.cdnURL;\n  const baseOrCdnURL = cdnURL && await isPrerendered(url) ? cdnURL : config.app.baseURL;\n  return joinURL(baseOrCdnURL, u.pathname, filename + (hash ? `?${hash}` : \"\"));\n}\nasync function _importPayload(payloadURL) {\n  if (import.meta.server || !payloadExtraction) {\n    return null;\n  }\n  const payloadPromise = renderJsonPayloads ? fetch(payloadURL, { cache: \"force-cache\" }).then((res) => res.text().then(parsePayload)) : import(\n    /* webpackIgnore: true */\n    /* @vite-ignore */\n    payloadURL\n  ).then((r) => r.default || r);\n  try {\n    return await payloadPromise;\n  } catch (err) {\n    console.warn(\"[nuxt] Cannot load payload \", payloadURL, err);\n  }\n  return null;\n}\nexport async function isPrerendered(url = useRoute().path) {\n  const nuxtApp = useNuxtApp();\n  if (!appManifest) {\n    return !!nuxtApp.payload.prerenderedAt;\n  }\n  url = withoutTrailingSlash(url);\n  const manifest = await getAppManifest();\n  if (manifest.prerendered.includes(url)) {\n    return true;\n  }\n  return nuxtApp.runWithContext(async () => {\n    const rules = await getRouteRules({ path: url });\n    return !!rules.prerender && !rules.redirect;\n  });\n}\nlet payloadCache = null;\nexport async function getNuxtClientPayload() {\n  if (import.meta.server) {\n    return null;\n  }\n  if (payloadCache) {\n    return payloadCache;\n  }\n  const el = multiApp ? document.querySelector(`[data-nuxt-data=\"${appId}\"]`) : document.getElementById(\"__NUXT_DATA__\");\n  if (!el) {\n    return {};\n  }\n  const inlineData = await parsePayload(el.textContent || \"\");\n  const externalData = el.dataset.src ? await _importPayload(el.dataset.src) : void 0;\n  payloadCache = {\n    ...inlineData,\n    ...externalData,\n    ...multiApp ? window.__NUXT__?.[appId] : window.__NUXT__\n  };\n  if (payloadCache.config?.public) {\n    payloadCache.config.public = reactive(payloadCache.config.public);\n  }\n  return payloadCache;\n}\nexport async function parsePayload(payload) {\n  return await parse(payload, useNuxtApp()._payloadRevivers);\n}\nexport function definePayloadReducer(name, reduce) {\n  if (import.meta.server) {\n    useNuxtApp().ssrContext._payloadReducers[name] = reduce;\n  }\n}\nexport function definePayloadReviver(name, revive) {\n  if (import.meta.dev && getCurrentInstance()) {\n    console.warn(\"[nuxt] [definePayloadReviver] This function must be called in a Nuxt plugin that is `unshift`ed to the beginning of the Nuxt plugins array.\");\n  }\n  if (import.meta.client) {\n    useNuxtApp()._payloadRevivers[name] = revive;\n  }\n}\n","import { isReactive, isRef, isShallow, toRaw } from \"vue\";\nimport { definePayloadReducer } from \"../composables/payload.js\";\nimport { isNuxtError } from \"../composables/error.js\";\nimport { defineNuxtPlugin } from \"../nuxt.js\";\nimport { componentIslands } from \"#build/nuxt.config.mjs\";\nimport { isValidIslandKey } from \"./utils.js\";\nconst reducers = [\n  [\"NuxtError\", (data) => isNuxtError(data) && data.toJSON()],\n  [\"EmptyShallowRef\", (data) => isRef(data) && isShallow(data) && !data.value && (typeof data.value === \"bigint\" ? \"0n\" : JSON.stringify(data.value) || \"_\")],\n  [\"EmptyRef\", (data) => isRef(data) && !data.value && (typeof data.value === \"bigint\" ? \"0n\" : JSON.stringify(data.value) || \"_\")],\n  [\"ShallowRef\", (data) => isRef(data) && isShallow(data) && data.value],\n  [\"ShallowReactive\", (data) => isReactive(data) && isShallow(data) && toRaw(data)],\n  [\"Ref\", (data) => isRef(data) && data.value],\n  [\"Reactive\", (data) => isReactive(data) && toRaw(data)]\n];\nif (componentIslands) {\n  reducers.push([\"Island\", (data) => data && data?.__nuxt_island && isValidIslandKey(data.__nuxt_island.key) && data.__nuxt_island]);\n}\nexport default defineNuxtPlugin({\n  name: \"nuxt:revive-payload:server\",\n  setup() {\n    for (const [reducer, fn] of reducers) {\n      definePayloadReducer(reducer, fn);\n    }\n  }\n});\n","<script>\nimport { defineComponent, h, useSlots } from \"vue\";\nimport { withTrailingSlash } from \"ufo\";\nimport ContentRenderer from \"./ContentRenderer.vue\";\nimport ContentQuery from \"./ContentQuery.vue\";\nimport { useRuntimeConfig, useRoute, useContentHead } from \"#imports\";\nconst ContentDoc = defineComponent({\n  name: \"ContentDoc\",\n  props: {\n    /**\n     * Renderer props\n     */\n    /**\n     * The tag to use for the renderer element if it is used.\n     * @default 'div'\n     */\n    tag: {\n      type: String,\n      required: false,\n      default: \"div\"\n    },\n    /**\n     * Whether or not to render the excerpt.\n     * @default false\n     */\n    excerpt: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * Query props\n     */\n    /**\n     * The path of the content to load from content source.\n     * @default useRoute().path\n     */\n    path: {\n      type: String,\n      required: false,\n      default: void 0\n    },\n    /**\n     * A query builder params object to be passed to <ContentQuery /> component.\n     */\n    query: {\n      type: Object,\n      required: false,\n      default: void 0\n    },\n    /**\n     * Whether or not to map the document data to the `head` property.\n     */\n    head: {\n      type: Boolean,\n      required: false,\n      default: void 0\n    }\n  },\n  /**\n   * Document empty fallback\n   * @slot empty\n   */\n  /**\n   * Document not found fallback\n   * @slot not-found\n   */\n  render(ctx) {\n    const { contentHead } = useRuntimeConfig().public.content;\n    const slots = useSlots();\n    const { tag, excerpt, path, query, head } = ctx;\n    const shouldInjectContentHead = head === void 0 ? contentHead : head;\n    const contentQueryProps = {\n      ...query || {},\n      path: path || query?.path || withTrailingSlash(useRoute().path),\n      find: \"one\"\n    };\n    const emptyNode = (slot, data) => h(\"pre\", null, JSON.stringify({ message: \"You should use slots with <ContentDoc>\", slot, data }, null, 2));\n    return h(\n      ContentQuery,\n      contentQueryProps,\n      {\n        // Default slot\n        default: slots?.default ? ({ data, refresh, isPartial }) => {\n          if (shouldInjectContentHead) {\n            useContentHead(data);\n          }\n          return slots.default?.({ doc: data, refresh, isPartial, excerpt, ...this.$attrs });\n        } : ({ data }) => {\n          if (shouldInjectContentHead) {\n            useContentHead(data);\n          }\n          return h(\n            ContentRenderer,\n            { value: data, excerpt, tag, ...this.$attrs },\n            // Forward local `empty` slots to ContentRenderer if it is used.\n            { empty: (bindings) => slots?.empty ? slots.empty(bindings) : emptyNode(\"default\", data) }\n          );\n        },\n        // Empty slot\n        empty: (bindings) => slots?.empty?.(bindings) || h(\"p\", null, \"Document is empty, overwrite this content with #empty slot in <ContentDoc>.\"),\n        // Not Found slot\n        \"not-found\": (bindings) => slots?.[\"not-found\"]?.(bindings) || h(\"p\", null, \"Document not found, overwrite this content with #not-found slot in <ContentDoc>.\")\n      }\n    );\n  }\n});\nexport default ContentDoc;\n</script>\n","<script>\nimport { defineComponent, h, useSlots } from \"vue\";\nimport ContentQuery from \"./ContentQuery.vue\";\nconst emptyNode = (slot, data) => h(\"pre\", null, JSON.stringify({ message: \"You should use slots with <ContentList>\", slot, data }, null, 2));\nconst ContentList = defineComponent({\n  name: \"ContentList\",\n  props: {\n    /**\n     * Query props\n     */\n    /**\n     * The path of the content to load from content source.\n     * @default '/'\n     */\n    path: {\n      type: String,\n      required: false,\n      default: void 0\n    },\n    /**\n     * A query builder params object to be passed to <ContentQuery /> component.\n     */\n    query: {\n      type: Object,\n      required: false,\n      default: void 0\n    }\n  },\n  /**\n   * Content empty fallback\n   * @slot empty\n   */\n  /**\n   * Content not found fallback\n   * @slot not-found\n   */\n  render(ctx) {\n    const slots = useSlots();\n    const { path, query } = ctx;\n    const contentQueryProps = {\n      ...query || {},\n      path: path || query?.path || \"/\"\n    };\n    return h(\n      ContentQuery,\n      contentQueryProps,\n      {\n        // Default slot\n        default: slots?.default ? ({ data, refresh, isPartial }) => slots.default({ list: data, refresh, isPartial, ...this.$attrs }) : (bindings) => emptyNode(\"default\", bindings.data),\n        // Empty slot\n        empty: (bindings) => slots?.empty ? slots.empty(bindings) : emptyNode(\"default\", bindings?.data),\n        // Not Found slot\n        \"not-found\": (bindings) => slots?.[\"not-found\"] ? slots?.[\"not-found\"]?.(bindings) : emptyNode(\"not-found\", bindings?.data)\n      }\n    );\n  }\n});\nexport default ContentList;\n</script>\n","<script>\nimport { toRefs, defineComponent, h, useSlots, computed } from \"vue\";\nimport { hash } from \"ohash\";\nimport { useAsyncData, fetchContentNavigation, useState, useContent } from \"#imports\";\nimport { NuxtLink } from \"#components\";\nconst ContentNavigation = defineComponent({\n  name: \"ContentNavigation\",\n  props: {\n    /**\n     * A query to be passed to `fetchContentNavigation()`.\n     */\n    query: {\n      type: Object,\n      required: false,\n      default: void 0\n    }\n  },\n  async setup(props) {\n    const {\n      query\n    } = toRefs(props);\n    const queryBuilder = computed(() => {\n      if (typeof query.value?.params === \"function\") {\n        return query.value.params();\n      }\n      return query.value;\n    });\n    if (!queryBuilder.value && useState(\"dd-navigation\").value) {\n      const { navigation: navigation2 } = useContent();\n      return { navigation: navigation2 };\n    }\n    const { data: navigation } = await useAsyncData(\n      `content-navigation-${hash(queryBuilder.value)}`,\n      () => fetchContentNavigation(queryBuilder.value)\n    );\n    return { navigation };\n  },\n  /**\n   * Navigation empty fallback\n   * @slot empty\n   */\n  render(ctx) {\n    const slots = useSlots();\n    const { navigation } = ctx;\n    const renderLink = (link) => h(NuxtLink, { to: link._path }, () => link.title);\n    const renderLinks = (data, level) => h(\n      \"ul\",\n      level ? { \"data-level\": level } : null,\n      data.map((link) => {\n        if (link.children) {\n          return h(\"li\", null, [renderLink(link), renderLinks(link.children, level + 1)]);\n        }\n        return h(\"li\", null, renderLink(link));\n      })\n    );\n    const defaultNode = (data) => renderLinks(data, 0);\n    return slots?.default ? slots.default({ navigation, ...this.$attrs }) : defaultNode(navigation);\n  }\n});\nexport default ContentNavigation;\n</script>\n","<script>\nimport { hash } from \"ohash\";\nimport { toRefs, defineComponent, h, useSlots, watch } from \"vue\";\nimport { computed, useAsyncData, queryContent, useRuntimeConfig } from \"#imports\";\nconst ContentQuery = defineComponent({\n  name: \"ContentQuery\",\n  props: {\n    /**\n     * The path of the content to load from content source.\n     */\n    path: {\n      type: String,\n      required: false,\n      default: void 0\n    },\n    /**\n     * Select a subset of fields\n     */\n    only: {\n      type: Array,\n      required: false,\n      default: void 0\n    },\n    /**\n     * Remove a subset of fields\n     */\n    without: {\n      type: Array,\n      required: false,\n      default: void 0\n    },\n    /**\n     * Filter results\n     */\n    where: {\n      type: Object,\n      required: false,\n      default: void 0\n    },\n    /**\n     * Sort results\n     */\n    sort: {\n      type: Object,\n      required: false,\n      default: void 0\n    },\n    /**\n     * Limit number of results\n     */\n    limit: {\n      type: Number,\n      required: false,\n      default: void 0\n    },\n    /**\n     * Skip number of results\n     */\n    skip: {\n      type: Number,\n      required: false,\n      default: void 0\n    },\n    /**\n     * Filter contents based on locale\n     */\n    locale: {\n      type: String,\n      required: false,\n      default: void 0\n    },\n    /**\n     * A type of query to be made.\n     */\n    find: {\n      type: String,\n      required: false,\n      default: void 0\n    }\n  },\n  async setup(props) {\n    const {\n      path,\n      only,\n      without,\n      where,\n      sort,\n      limit,\n      skip,\n      locale,\n      find\n    } = toRefs(props);\n    const isPartial = computed(() => path.value?.includes(\"/_\"));\n    const legacy = !useRuntimeConfig().public.content.experimental.advanceQuery;\n    watch(() => props, () => refresh(), { deep: true });\n    const resolveResult = (result) => {\n      if (legacy) {\n        if (result?.surround) {\n          return result.surround;\n        }\n        return result?._id || Array.isArray(result) ? result : result?.result;\n      }\n      return result.result;\n    };\n    const { data, refresh } = await useAsyncData(\n      `content-query-${hash(props)}`,\n      () => {\n        let queryBuilder;\n        if (path.value) {\n          queryBuilder = queryContent(path.value);\n        } else {\n          queryBuilder = queryContent();\n        }\n        if (only.value) {\n          queryBuilder = queryBuilder.only(only.value);\n        }\n        if (without.value) {\n          queryBuilder = queryBuilder.without(without.value);\n        }\n        if (where.value) {\n          queryBuilder = queryBuilder.where(where.value);\n        }\n        if (sort.value) {\n          queryBuilder = queryBuilder.sort(sort.value);\n        }\n        if (limit.value) {\n          queryBuilder = queryBuilder.limit(limit.value);\n        }\n        if (skip.value) {\n          queryBuilder = queryBuilder.skip(skip.value);\n        }\n        if (locale.value) {\n          queryBuilder = queryBuilder.where({ _locale: locale.value });\n        }\n        if (find.value === \"one\") {\n          return queryBuilder.findOne().then(resolveResult);\n        }\n        if (find.value === \"surround\") {\n          if (!path.value) {\n            console.warn(\"[Content] Surround queries requires `path` prop to be set.\");\n            console.warn(\"[Content] Query without `path` will return regular `find()` results.\");\n            return queryBuilder.find().then(resolveResult);\n          }\n          if (legacy) {\n            return queryBuilder.findSurround(path.value);\n          } else {\n            return queryBuilder.withSurround(path.value).findOne().then(resolveResult);\n          }\n        }\n        return queryBuilder.find().then(resolveResult);\n      }\n    );\n    return {\n      isPartial,\n      data,\n      refresh\n    };\n  },\n  /**\n   * Content not found fallback\n   * @slot not-found\n   */\n  render(ctx) {\n    const slots = useSlots();\n    const {\n      // Setup\n      data,\n      refresh,\n      isPartial,\n      // Props\n      path,\n      only,\n      without,\n      where,\n      sort,\n      limit,\n      skip,\n      locale,\n      find\n    } = ctx;\n    const props = {\n      path,\n      only,\n      without,\n      where,\n      sort,\n      limit,\n      skip,\n      locale,\n      find\n    };\n    if (props.find === \"one\") {\n      if (!data && slots?.[\"not-found\"]) {\n        return slots[\"not-found\"]({ props, ...this.$attrs });\n      }\n      if (slots?.empty && data?._type === \"markdown\" && !data?.body?.children.length) {\n        return slots.empty({ props, ...this.$attrs });\n      }\n    } else if (!data || !data.length) {\n      if (slots?.[\"not-found\"]) {\n        return slots[\"not-found\"]({ props, ...this.$attrs });\n      }\n    }\n    if (slots?.default) {\n      return slots.default({ data, refresh, isPartial, props, ...this.$attrs });\n    }\n    const emptyNode = (slot, data2) => h(\"pre\", null, JSON.stringify({ message: \"You should use slots with <ContentQuery>!\", slot, data: data2 }, null, 2));\n    return emptyNode(\"default\", { data, props, isPartial });\n  }\n});\nexport default ContentQuery;\n</script>\n","<script>\nimport { defineComponent, watch, h, useSlots } from \"vue\";\nimport ContentRendererMarkdown from \"./ContentRendererMarkdown.vue\";\nexport default defineComponent({\n  name: \"ContentRenderer\",\n  props: {\n    /**\n     * The document to render.\n     */\n    value: {\n      type: Object,\n      required: false,\n      default: () => ({})\n    },\n    /**\n     * Whether or not to render the excerpt.\n     * @default false\n     */\n    excerpt: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * The tag to use for the renderer element if it is used.\n     * @default 'div'\n     */\n    tag: {\n      type: String,\n      default: \"div\"\n    }\n  },\n  setup(props) {\n    watch(\n      () => props.excerpt,\n      (newExcerpt) => {\n        if (newExcerpt && !props.value?.excerpt) {\n          console.warn(`No excerpt found for document content/${props?.value?._path}.${props?.value?._extension}!`);\n          console.warn(\"Make sure to use <!--more--> in your content if you want to use excerpt feature.\");\n        }\n      },\n      {\n        immediate: true\n      }\n    );\n  },\n  /**\n   * Content empty fallback\n   * @slot empty\n   */\n  render(ctx) {\n    const slots = useSlots();\n    const { value, excerpt, tag } = ctx;\n    const markdownAST = excerpt ? value?.excerpt : value?.body;\n    if (!markdownAST?.children?.length && slots?.empty) {\n      return slots.empty({ value, excerpt, tag, ...this.$attrs });\n    }\n    if (slots?.default) {\n      return slots.default({ value, excerpt, tag, ...this.$attrs });\n    }\n    if (markdownAST?.type === \"root\" && markdownAST?.children?.length) {\n      return h(\n        ContentRendererMarkdown,\n        {\n          value,\n          excerpt,\n          tag,\n          ...this.$attrs\n        }\n      );\n    }\n    return h(\n      \"pre\",\n      null,\n      JSON.stringify({ message: \"You should use slots with <ContentRenderer>\", value, excerpt, tag }, null, 2)\n    );\n  }\n});\n</script>\n","<script>\nimport { defineComponent, h, resolveComponent } from \"vue\";\nexport default defineComponent({\n  props: {\n    /**\n     * A slot name or function\n     */\n    use: {\n      type: Function,\n      default: void 0\n    },\n    /**\n     * Tags to unwrap separated by spaces\n     * Example: 'ul li'\n     */\n    unwrap: {\n      type: [Boolean, String],\n      default: false\n    }\n  },\n  render(props) {\n    return h(resolveComponent(\"MDCSlot\"), props);\n  }\n});\n</script>\n","<script>\nimport { defineComponent, h } from \"vue\";\nexport default defineComponent({\n  name: \"DocumentDrivenEmpty\",\n  props: {\n    value: {\n      type: Object,\n      required: true\n    }\n  },\n  render({ value }) {\n    return h(\"div\", void 0, [\n      h(\"p\", \"Document is empty\"),\n      h(\"p\", `Add content to it by opening ${value._source}/${value._file} file.`)\n    ]);\n  }\n});\n</script>\n","<script>\nimport { defineComponent, h } from \"vue\";\nexport default defineComponent({\n  name: \"DocumentDrivenNotFound\",\n  render() {\n    return h(\"div\", \"Document not found\");\n  }\n});\n</script>\n","import { setResponseStatus as _setResponseStatus, appendHeader, getRequestHeader, getRequestHeaders, getResponseHeader, removeResponseHeader, setResponseHeader } from \"h3\";\nimport { computed, getCurrentInstance, ref } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { toArray } from \"../utils.js\";\nimport { useHead } from \"./head.js\";\nexport function useRequestEvent(nuxtApp) {\n  if (import.meta.client) {\n    return;\n  }\n  nuxtApp ||= useNuxtApp();\n  return nuxtApp.ssrContext?.event;\n}\nexport function useRequestHeaders(include) {\n  if (import.meta.client) {\n    return {};\n  }\n  const event = useRequestEvent();\n  const _headers = event ? getRequestHeaders(event) : {};\n  if (!include || !event) {\n    return _headers;\n  }\n  const headers = /* @__PURE__ */ Object.create(null);\n  for (const _key of include) {\n    const key = _key.toLowerCase();\n    const header = _headers[key];\n    if (header) {\n      headers[key] = header;\n    }\n  }\n  return headers;\n}\nexport function useRequestHeader(header) {\n  if (import.meta.client) {\n    return void 0;\n  }\n  const event = useRequestEvent();\n  return event ? getRequestHeader(event, header) : void 0;\n}\nexport function useRequestFetch() {\n  if (import.meta.client) {\n    return globalThis.$fetch;\n  }\n  return useRequestEvent()?.$fetch || globalThis.$fetch;\n}\nexport function setResponseStatus(arg1, arg2, arg3) {\n  if (import.meta.client) {\n    return;\n  }\n  if (arg1 && typeof arg1 !== \"number\") {\n    return _setResponseStatus(arg1, arg2, arg3);\n  }\n  const event = useRequestEvent();\n  if (event) {\n    return _setResponseStatus(event, arg1, arg2);\n  }\n}\nexport function useResponseHeader(header) {\n  if (import.meta.client) {\n    if (import.meta.dev) {\n      return computed({\n        get: () => void 0,\n        set: () => console.warn(\"[nuxt] Setting response headers is not supported in the browser.\")\n      });\n    }\n    return ref();\n  }\n  const event = useRequestEvent();\n  return computed({\n    get() {\n      return getResponseHeader(event, header);\n    },\n    set(newValue) {\n      if (!newValue) {\n        return removeResponseHeader(event, header);\n      }\n      return setResponseHeader(event, header, newValue);\n    }\n  });\n}\nexport function prerenderRoutes(path) {\n  if (!import.meta.server || !import.meta.prerender) {\n    return;\n  }\n  const paths = toArray(path);\n  appendHeader(useRequestEvent(), \"x-nitro-prerender\", paths.map((p) => encodeURIComponent(p)).join(\", \"));\n}\nconst PREHYDRATE_ATTR_KEY = \"data-prehydrate-id\";\nexport function onPrehydrate(callback, key) {\n  if (import.meta.client) {\n    return;\n  }\n  if (typeof callback !== \"string\") {\n    throw new TypeError(\"[nuxt] To transform a callback into a string, `onPrehydrate` must be processed by the Nuxt build pipeline. If it is called in a third-party library, make sure to add the library to `build.transpile`.\");\n  }\n  const vm = getCurrentInstance();\n  if (vm && key) {\n    vm.attrs[PREHYDRATE_ATTR_KEY] ||= \"\";\n    key = \":\" + key + \":\";\n    if (!vm.attrs[PREHYDRATE_ATTR_KEY].includes(key)) {\n      vm.attrs[PREHYDRATE_ATTR_KEY] += key;\n    }\n  }\n  const code = vm && key ? `document.querySelectorAll('[${PREHYDRATE_ATTR_KEY}*=${JSON.stringify(key)}]').forEach` + callback : callback + \"()\";\n  useHead({\n    script: [{\n      key: vm && key ? key : void 0,\n      tagPosition: \"bodyClose\",\n      tagPriority: \"critical\",\n      innerHTML: code\n    }]\n  });\n  return vm && key ? vm.attrs[PREHYDRATE_ATTR_KEY] : void 0;\n}\n","import { joinURL } from \"ufo\";\nimport { createRouter as createRadixRouter, toRouteMatcher } from \"radix3\";\nimport defu from \"defu\";\nimport { defineNuxtPlugin, useRuntimeConfig } from \"#app/nuxt\";\nimport { prerenderRoutes } from \"#app/composables/ssr\";\nimport _routes from \"#build/routes\";\nimport routerOptions, { hashMode } from \"#build/router.options\";\nimport { crawlLinks } from \"#build/nuxt.config.mjs\";\nlet routes;\nlet _routeRulesMatcher = void 0;\nexport default defineNuxtPlugin(async () => {\n  if (!import.meta.server || !import.meta.prerender || hashMode) {\n    return;\n  }\n  if (routes && !routes.length) {\n    return;\n  }\n  const routeRules = useRuntimeConfig().nitro.routeRules;\n  if (!crawlLinks && routeRules && Object.values(routeRules).some((r) => r.prerender)) {\n    _routeRulesMatcher = toRouteMatcher(createRadixRouter({ routes: routeRules }));\n  }\n  routes ||= Array.from(processRoutes(await routerOptions.routes?.(_routes) ?? _routes));\n  const batch = routes.splice(0, 10);\n  prerenderRoutes(batch);\n});\nconst OPTIONAL_PARAM_RE = /^\\/?:.*(?:\\?|\\(\\.\\*\\)\\*)$/;\nfunction shouldPrerender(path) {\n  return !_routeRulesMatcher || defu({}, ..._routeRulesMatcher.matchAll(path).reverse()).prerender;\n}\nfunction processRoutes(routes2, currentPath = \"/\", routesToPrerender = /* @__PURE__ */ new Set()) {\n  for (const route of routes2) {\n    if (OPTIONAL_PARAM_RE.test(route.path) && !route.children?.length && shouldPrerender(currentPath)) {\n      routesToPrerender.add(currentPath);\n    }\n    if (route.path.includes(\":\")) {\n      continue;\n    }\n    const fullPath = joinURL(currentPath, route.path);\n    if (shouldPrerender(fullPath)) {\n      routesToPrerender.add(fullPath);\n    }\n    if (route.children) {\n      processRoutes(route.children, fullPath, routesToPrerender);\n    }\n  }\n  return routesToPrerender;\n}\n","import unhead_k2P3m_ZDyjlr2mMYnoDPwavjsDN8hBlk9cFai0bbopU from \"C:/Users/sao/Documents/my-site/node_modules/nuxt/dist/head/runtime/plugins/unhead.js\";\nimport router_GNCWhvtYfLTYRZZ135CdFAEjxdMexN0ixiUYCAN_tpw from \"C:/Users/sao/Documents/my-site/node_modules/nuxt/dist/pages/runtime/plugins/router.js\";\nimport revive_payload_server_MVtmlZaQpj6ApFmshWfUWl5PehCebzaBf2NuRMiIbms from \"C:/Users/sao/Documents/my-site/node_modules/nuxt/dist/app/plugins/revive-payload.server.js\";\nimport components_plugin_z4hgvsiddfKkfXTP6M8M4zG5Cb7sGnDhcryKVM45Di4 from \"C:/Users/sao/Documents/my-site/.nuxt/components.plugin.mjs\";\nimport prerender_server_sqIxOBipVr4FbVMA9kqWL0wT8FPop6sKAXLVfifsJzk from \"C:/Users/sao/Documents/my-site/node_modules/nuxt/dist/pages/runtime/plugins/prerender.server.js\";\nexport default [\n  unhead_k2P3m_ZDyjlr2mMYnoDPwavjsDN8hBlk9cFai0bbopU,\n  router_GNCWhvtYfLTYRZZ135CdFAEjxdMexN0ixiUYCAN_tpw,\n  revive_payload_server_MVtmlZaQpj6ApFmshWfUWl5PehCebzaBf2NuRMiIbms,\n  components_plugin_z4hgvsiddfKkfXTP6M8M4zG5Cb7sGnDhcryKVM45Di4,\n  prerender_server_sqIxOBipVr4FbVMA9kqWL0wT8FPop6sKAXLVfifsJzk\n]","import { defineAsyncComponent } from 'vue'\nexport default {\n  default: defineAsyncComponent(() => import(\"C:/Users/sao/Documents/my-site/layouts/default.vue\").then(m => m.default || m))\n}","import { Suspense, computed, defineComponent, h, inject, mergeProps, nextTick, onMounted, provide, shallowReactive, shallowRef, unref } from \"vue\";\nimport { useRoute, useRouter } from \"../composables/router.js\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { _wrapInTransition } from \"./utils.js\";\nimport { LayoutMetaSymbol, PageRouteSymbol } from \"./injections.js\";\nimport { useRoute as useVueRouterRoute } from \"#build/pages\";\nimport layouts from \"#build/layouts\";\nimport { appLayoutTransition as defaultLayoutTransition } from \"#build/nuxt.config.mjs\";\nconst LayoutLoader = defineComponent({\n  name: \"LayoutLoader\",\n  inheritAttrs: false,\n  props: {\n    name: String,\n    layoutProps: Object\n  },\n  setup(props, context) {\n    return () => h(layouts[props.name], props.layoutProps, context.slots);\n  }\n});\nconst nuxtLayoutProps = {\n  name: {\n    type: [String, Boolean, Object],\n    default: null\n  },\n  fallback: {\n    type: [String, Object],\n    default: null\n  }\n};\nexport default defineComponent({\n  name: \"NuxtLayout\",\n  inheritAttrs: false,\n  props: nuxtLayoutProps,\n  setup(props, context) {\n    const nuxtApp = useNuxtApp();\n    const injectedRoute = inject(PageRouteSymbol);\n    const shouldUseEagerRoute = !injectedRoute || injectedRoute === useRoute();\n    const route = shouldUseEagerRoute ? useVueRouterRoute() : injectedRoute;\n    const layout = computed(() => {\n      let layout2 = unref(props.name) ?? route?.meta.layout ?? \"default\";\n      if (layout2 && !(layout2 in layouts)) {\n        if (import.meta.dev && layout2 !== \"default\") {\n          console.warn(`Invalid layout \\`${layout2}\\` selected.`);\n        }\n        if (props.fallback) {\n          layout2 = unref(props.fallback);\n        }\n      }\n      return layout2;\n    });\n    const layoutRef = shallowRef();\n    context.expose({ layoutRef });\n    const done = nuxtApp.deferHydration();\n    if (import.meta.client && nuxtApp.isHydrating) {\n      const removeErrorHook = nuxtApp.hooks.hookOnce(\"app:error\", done);\n      useRouter().beforeEach(removeErrorHook);\n    }\n    if (import.meta.dev) {\n      nuxtApp._isNuxtLayoutUsed = true;\n    }\n    let lastLayout;\n    return () => {\n      const hasLayout = layout.value && layout.value in layouts;\n      const transitionProps = route?.meta.layoutTransition ?? defaultLayoutTransition;\n      const previouslyRenderedLayout = lastLayout;\n      lastLayout = layout.value;\n      return _wrapInTransition(hasLayout && transitionProps, {\n        default: () => h(Suspense, { suspensible: true, onResolve: () => {\n          nextTick(done);\n        } }, {\n          default: () => h(\n            LayoutProvider,\n            {\n              layoutProps: mergeProps(context.attrs, { ref: layoutRef }),\n              key: layout.value || void 0,\n              name: layout.value,\n              shouldProvide: !props.name,\n              isRenderingNewLayout: (name) => {\n                return name !== previouslyRenderedLayout && name === layout.value;\n              },\n              hasTransition: !!transitionProps\n            },\n            context.slots\n          )\n        })\n      }).default();\n    };\n  }\n});\nconst LayoutProvider = defineComponent({\n  name: \"NuxtLayoutProvider\",\n  inheritAttrs: false,\n  props: {\n    name: {\n      type: [String, Boolean]\n    },\n    layoutProps: {\n      type: Object\n    },\n    hasTransition: {\n      type: Boolean\n    },\n    shouldProvide: {\n      type: Boolean\n    },\n    isRenderingNewLayout: {\n      type: Function,\n      required: true\n    }\n  },\n  setup(props, context) {\n    const name = props.name;\n    if (props.shouldProvide) {\n      provide(LayoutMetaSymbol, {\n        isCurrent: (route) => name === (route.meta.layout ?? \"default\")\n      });\n    }\n    const injectedRoute = inject(PageRouteSymbol);\n    const isNotWithinNuxtPage = injectedRoute && injectedRoute === useRoute();\n    if (isNotWithinNuxtPage) {\n      const vueRouterRoute = useVueRouterRoute();\n      const reactiveChildRoute = {};\n      for (const _key in vueRouterRoute) {\n        const key = _key;\n        Object.defineProperty(reactiveChildRoute, key, {\n          enumerable: true,\n          get: () => {\n            return props.isRenderingNewLayout(props.name) ? vueRouterRoute[key] : injectedRoute[key];\n          }\n        });\n      }\n      provide(PageRouteSymbol, shallowReactive(reactiveChildRoute));\n    }\n    let vnode;\n    if (import.meta.dev && import.meta.client) {\n      onMounted(() => {\n        nextTick(() => {\n          if ([\"#comment\", \"#text\"].includes(vnode?.el?.nodeName)) {\n            if (name) {\n              console.warn(`[nuxt] \\`${name}\\` layout does not have a single root node and will cause errors when navigating between routes.`);\n            } else {\n              console.warn(\"[nuxt] `<NuxtLayout>` needs to be passed a single root node in its default slot.\");\n            }\n          }\n        });\n      });\n    }\n    return () => {\n      if (!name || typeof name === \"string\" && !(name in layouts)) {\n        if (import.meta.dev && import.meta.client && props.hasTransition) {\n          vnode = context.slots.default?.();\n          return vnode;\n        }\n        return context.slots.default?.();\n      }\n      if (import.meta.dev && import.meta.client && props.hasTransition) {\n        vnode = h(\n          LayoutLoader,\n          { key: name, layoutProps: props.layoutProps, name },\n          context.slots\n        );\n        return vnode;\n      }\n      return h(\n        LayoutLoader,\n        { key: name, layoutProps: props.layoutProps, name },\n        context.slots\n      );\n    };\n  }\n});\n","import { defineComponent, h, nextTick, onMounted, provide, shallowReactive } from \"vue\";\nimport { PageRouteSymbol } from \"./injections.js\";\nexport const defineRouteProvider = (name = \"RouteProvider\") => defineComponent({\n  name,\n  props: {\n    route: {\n      type: Object,\n      required: true\n    },\n    vnode: Object,\n    vnodeRef: Object,\n    renderKey: String,\n    trackRootNodes: Boolean\n  },\n  setup(props) {\n    const previousKey = props.renderKey;\n    const previousRoute = props.route;\n    const route = {};\n    for (const key in props.route) {\n      Object.defineProperty(route, key, {\n        get: () => previousKey === props.renderKey ? props.route[key] : previousRoute[key],\n        enumerable: true\n      });\n    }\n    provide(PageRouteSymbol, shallowReactive(route));\n    let vnode;\n    if (import.meta.dev && import.meta.client && props.trackRootNodes) {\n      onMounted(() => {\n        nextTick(() => {\n          if ([\"#comment\", \"#text\"].includes(vnode?.el?.nodeName)) {\n            const filename = vnode?.type?.__file;\n            console.warn(`[nuxt] \\`${filename}\\` does not have a single root node and will cause errors when navigating between routes.`);\n          }\n        });\n      });\n    }\n    return () => {\n      if (!props.vnode) {\n        return props.vnode;\n      }\n      if (import.meta.dev && import.meta.client) {\n        vnode = h(props.vnode, { ref: props.vnodeRef });\n        return vnode;\n      }\n      return h(props.vnode, { ref: props.vnodeRef });\n    };\n  }\n});\nexport const RouteProvider = defineRouteProvider();\n","import { Fragment, Suspense, defineComponent, h, inject, nextTick, onBeforeUnmount, ref, watch } from \"vue\";\nimport { RouterView } from \"vue-router\";\nimport { defu } from \"defu\";\nimport { generateRouteKey, toArray, wrapInKeepAlive } from \"./utils.js\";\nimport { RouteProvider, defineRouteProvider } from \"#app/components/route-provider\";\nimport { useNuxtApp } from \"#app/nuxt\";\nimport { useRouter } from \"#app/composables/router\";\nimport { _wrapInTransition } from \"#app/components/utils\";\nimport { LayoutMetaSymbol, PageRouteSymbol } from \"#app/components/injections\";\nimport { appKeepalive as defaultKeepaliveConfig, appPageTransition as defaultPageTransition } from \"#build/nuxt.config.mjs\";\nconst _routeProviders = import.meta.dev ? /* @__PURE__ */ new Map() : /* @__PURE__ */ new WeakMap();\nexport default defineComponent({\n  name: \"NuxtPage\",\n  inheritAttrs: false,\n  props: {\n    name: {\n      type: String\n    },\n    transition: {\n      type: [Boolean, Object],\n      default: void 0\n    },\n    keepalive: {\n      type: [Boolean, Object],\n      default: void 0\n    },\n    route: {\n      type: Object\n    },\n    pageKey: {\n      type: [Function, String],\n      default: null\n    }\n  },\n  setup(props, { attrs, slots, expose }) {\n    const nuxtApp = useNuxtApp();\n    const pageRef = ref();\n    const forkRoute = inject(PageRouteSymbol, null);\n    let previousPageKey;\n    expose({ pageRef });\n    const _layoutMeta = inject(LayoutMetaSymbol, null);\n    let vnode;\n    const done = nuxtApp.deferHydration();\n    if (import.meta.client && nuxtApp.isHydrating) {\n      const removeErrorHook = nuxtApp.hooks.hookOnce(\"app:error\", done);\n      useRouter().beforeEach(removeErrorHook);\n    }\n    if (import.meta.client && props.pageKey) {\n      watch(() => props.pageKey, (next, prev) => {\n        if (next !== prev) {\n          nuxtApp.callHook(\"page:loading:start\");\n        }\n      });\n    }\n    if (import.meta.dev) {\n      nuxtApp._isNuxtPageUsed = true;\n    }\n    let pageLoadingEndHookAlreadyCalled = false;\n    if (import.meta.client) {\n      const unsub = useRouter().beforeResolve(() => {\n        pageLoadingEndHookAlreadyCalled = false;\n      });\n      onBeforeUnmount(() => {\n        unsub();\n      });\n    }\n    return () => {\n      return h(RouterView, { name: props.name, route: props.route, ...attrs }, {\n        default: import.meta.server ? (routeProps) => {\n          return h(Suspense, { suspensible: true }, {\n            default() {\n              return h(RouteProvider, {\n                vnode: slots.default ? normalizeSlot(slots.default, routeProps) : routeProps.Component,\n                route: routeProps.route,\n                vnodeRef: pageRef\n              });\n            }\n          });\n        } : (routeProps) => {\n          const isRenderingNewRouteInOldFork = haveParentRoutesRendered(forkRoute, routeProps.route, routeProps.Component);\n          const hasSameChildren = forkRoute && forkRoute.matched.length === routeProps.route.matched.length;\n          if (!routeProps.Component) {\n            if (vnode && !hasSameChildren) {\n              return vnode;\n            }\n            done();\n            return;\n          }\n          if (vnode && _layoutMeta && !_layoutMeta.isCurrent(routeProps.route)) {\n            return vnode;\n          }\n          if (isRenderingNewRouteInOldFork && forkRoute && (!_layoutMeta || _layoutMeta?.isCurrent(forkRoute))) {\n            if (hasSameChildren) {\n              return vnode;\n            }\n            return null;\n          }\n          const key = generateRouteKey(routeProps, props.pageKey);\n          const willRenderAnotherChild = hasChildrenRoutes(forkRoute, routeProps.route, routeProps.Component);\n          if (!nuxtApp.isHydrating && previousPageKey === key && !willRenderAnotherChild) {\n            nextTick(() => {\n              pageLoadingEndHookAlreadyCalled = true;\n              nuxtApp.callHook(\"page:loading:end\");\n            });\n          }\n          previousPageKey = key;\n          const hasTransition = !!(props.transition ?? routeProps.route.meta.pageTransition ?? defaultPageTransition);\n          const transitionProps = hasTransition && _mergeTransitionProps([\n            props.transition,\n            routeProps.route.meta.pageTransition,\n            defaultPageTransition,\n            {\n              onAfterLeave() {\n                delete nuxtApp._runningTransition;\n                nuxtApp.callHook(\"page:transition:finish\", routeProps.Component);\n              }\n            }\n          ]);\n          const keepaliveConfig = props.keepalive ?? routeProps.route.meta.keepalive ?? defaultKeepaliveConfig;\n          vnode = _wrapInTransition(\n            hasTransition && transitionProps,\n            wrapInKeepAlive(\n              keepaliveConfig,\n              h(Suspense, {\n                suspensible: true,\n                onPending: () => {\n                  if (hasTransition) {\n                    nuxtApp._runningTransition = true;\n                  }\n                  nuxtApp.callHook(\"page:start\", routeProps.Component);\n                },\n                onResolve: () => {\n                  nextTick(() => nuxtApp.callHook(\"page:finish\", routeProps.Component).then(() => {\n                    delete nuxtApp._runningTransition;\n                    if (!pageLoadingEndHookAlreadyCalled && !willRenderAnotherChild) {\n                      pageLoadingEndHookAlreadyCalled = true;\n                      return nuxtApp.callHook(\"page:loading:end\");\n                    }\n                  }).finally(done));\n                }\n              }, {\n                default: () => {\n                  const routeProviderProps = {\n                    key: key || void 0,\n                    vnode: slots.default ? normalizeSlot(slots.default, routeProps) : routeProps.Component,\n                    route: routeProps.route,\n                    renderKey: key || void 0,\n                    trackRootNodes: hasTransition,\n                    vnodeRef: pageRef\n                  };\n                  if (!keepaliveConfig) {\n                    return h(RouteProvider, routeProviderProps);\n                  }\n                  const routerComponentType = routeProps.Component.type;\n                  const routeProviderKey = import.meta.dev ? routerComponentType.name || routerComponentType.__name : routerComponentType;\n                  let PageRouteProvider = _routeProviders.get(routeProviderKey);\n                  if (!PageRouteProvider) {\n                    PageRouteProvider = defineRouteProvider(routerComponentType.name || routerComponentType.__name);\n                    _routeProviders.set(routeProviderKey, PageRouteProvider);\n                  }\n                  return h(PageRouteProvider, routeProviderProps);\n                }\n              })\n            )\n          ).default();\n          return vnode;\n        }\n      });\n    };\n  }\n});\nfunction _mergeTransitionProps(routeProps) {\n  const _props = [];\n  for (const prop of routeProps) {\n    if (!prop) {\n      continue;\n    }\n    _props.push({\n      ...prop,\n      onAfterLeave: prop.onAfterLeave ? toArray(prop.onAfterLeave) : void 0\n    });\n  }\n  return defu(..._props);\n}\nfunction haveParentRoutesRendered(fork, newRoute, Component) {\n  if (!fork) {\n    return false;\n  }\n  const index = newRoute.matched.findIndex((m) => m.components?.default === Component?.type);\n  if (!index || index === -1) {\n    return false;\n  }\n  return newRoute.matched.slice(0, index).some(\n    (c, i) => c.components?.default !== fork.matched[i]?.components?.default\n  ) || Component && generateRouteKey({ route: newRoute, Component }) !== generateRouteKey({ route: fork, Component });\n}\nfunction hasChildrenRoutes(fork, newRoute, Component) {\n  if (!fork) {\n    return false;\n  }\n  const index = newRoute.matched.findIndex((m) => m.components?.default === Component?.type);\n  return index < newRoute.matched.length - 1;\n}\nfunction normalizeSlot(slot, data) {\n  const slotContent = slot(data);\n  return slotContent.length === 1 ? h(slotContent[0]) : h(Fragment, void 0, slotContent);\n}\n","<template>\n  <div>\n    <NuxtLayout>\n      <NuxtPage />\n    </NuxtLayout>\n  </div>\n</template>\n\n<script setup>\n// Global meta tags and SEO\nuseSeoMeta({\n  titleTemplate: '%s | Professional Business Template',\n  description: 'Modern, responsive website template for businesses and professionals',\n  ogDescription: 'Modern, responsive website template for businesses and professionals',\n  ogImage: '/images/og-image.jpg',\n  twitterCard: 'summary_large_image'\n})\n</script>\n","<template>\n  <ErrorTemplate v-bind=\"{ statusCode, statusMessage, description, stack }\" />\n</template>\n\n<script setup>\nimport { defineAsyncComponent } from \"vue\";\nconst props = defineProps({\n  error: Object\n});\nconst _error = props.error;\nconst stacktrace = _error.stack ? _error.stack.split(\"\\n\").splice(1).map((line) => {\n  const text = line.replace(\"webpack:/\", \"\").replace(\".vue\", \".js\").trim();\n  return {\n    text,\n    internal: line.includes(\"node_modules\") && !line.includes(\".cache\") || line.includes(\"internal\") || line.includes(\"new Promise\")\n  };\n}).map((i) => `<span class=\"stack${i.internal ? \" internal\" : \"\"}\">${i.text}</span>`).join(\"\\n\") : \"\";\nconst statusCode = Number(_error.statusCode || 500);\nconst is404 = statusCode === 404;\nconst statusMessage = _error.statusMessage ?? (is404 ? \"Page Not Found\" : \"Internal Server Error\");\nconst description = _error.message || _error.toString();\nconst stack = import.meta.dev && !is404 ? _error.description || `<pre>${stacktrace}</pre>` : void 0;\nconst _Error404 = defineAsyncComponent(() => import(\"./error-404.vue\"));\nconst _Error = import.meta.dev ? defineAsyncComponent(() => import(\"./error-dev.vue\")) : defineAsyncComponent(() => import(\"./error-500.vue\"));\nconst ErrorTemplate = is404 ? _Error404 : _Error;\n</script>\n","<template>\n  <Suspense @resolve=\"onResolve\">\n    <div v-if=\"abortRender\" />\n    <ErrorComponent\n      v-else-if=\"error\"\n      :error=\"error\"\n    />\n    <IslandRenderer\n      v-else-if=\"islandContext\"\n      :context=\"islandContext\"\n    />\n    <component\n      :is=\"SingleRenderer\"\n      v-else-if=\"SingleRenderer\"\n    />\n    <AppComponent v-else />\n  </Suspense>\n</template>\n\n<script setup>\nimport { defineAsyncComponent, onErrorCaptured, onServerPrefetch, provide } from \"vue\";\nimport { useNuxtApp } from \"../nuxt\";\nimport { isNuxtError, showError, useError } from \"../composables/error\";\nimport { useRoute, useRouter } from \"../composables/router\";\nimport { PageRouteSymbol } from \"../components/injections\";\nimport AppComponent from \"#build/app-component.mjs\";\nimport ErrorComponent from \"#build/error-component.mjs\";\nimport { componentIslands } from \"#build/nuxt.config.mjs\";\nconst IslandRenderer = import.meta.server && componentIslands ? defineAsyncComponent(() => import(\"./island-renderer\").then((r) => r.default || r)) : () => null;\nconst nuxtApp = useNuxtApp();\nconst onResolve = nuxtApp.deferHydration();\nif (import.meta.client && nuxtApp.isHydrating) {\n  const removeErrorHook = nuxtApp.hooks.hookOnce(\"app:error\", onResolve);\n  useRouter().beforeEach(removeErrorHook);\n}\nconst url = import.meta.server ? nuxtApp.ssrContext.url : window.location.pathname;\nconst SingleRenderer = import.meta.test && import.meta.dev && import.meta.server && url.startsWith(\"/__nuxt_component_test__/\") && defineAsyncComponent(() => import(\"#build/test-component-wrapper.mjs\").then((r) => r.default(import.meta.server ? url : window.location.href)));\nprovide(PageRouteSymbol, useRoute());\nconst results = nuxtApp.hooks.callHookWith((hooks) => hooks.map((hook) => hook()), \"vue:setup\");\nif (import.meta.dev && results && results.some((i) => i && \"then\" in i)) {\n  console.error(\"[nuxt] Error in `vue:setup`. Callbacks must be synchronous.\");\n}\nconst error = useError();\nconst abortRender = import.meta.server && error.value && !nuxtApp.ssrContext.error;\nconst BOT_RE = /bot\\b|chrome-lighthouse|facebookexternalhit|google\\b/i;\nonErrorCaptured((err, target, info) => {\n  nuxtApp.hooks.callHook(\"vue:error\", err, target, info).catch((hookError) => console.error(\"[nuxt] Error in `vue:error` hook\", hookError));\n  if (import.meta.client && BOT_RE.test(navigator.userAgent)) {\n    nuxtApp.hooks.callHook(\"app:error\", err);\n    console.error(`[nuxt] Not rendering error page for bot with user agent \\`${navigator.userAgent}\\`:`, err);\n    return false;\n  }\n  if (import.meta.server || isNuxtError(err) && (err.fatal || err.unhandled)) {\n    const p = nuxtApp.runWithContext(() => showError(err));\n    onServerPrefetch(() => p);\n    return false;\n  }\n});\nconst islandContext = import.meta.server && nuxtApp.ssrContext.islandContext;\n</script>\n","import { createApp, createSSRApp, nextTick } from \"vue\";\nimport \"#build/fetch.mjs\";\nimport \"#build/global-polyfills.mjs\";\nimport { applyPlugins, createNuxtApp } from \"./nuxt.js\";\nimport { createError } from \"./composables/error.js\";\nimport \"#build/css\";\nimport plugins from \"#build/plugins\";\nimport RootComponent from \"#build/root-component.mjs\";\nimport { appId, appSpaLoaderAttrs, multiApp, spaLoadingTemplateOutside, vueAppRootContainer } from \"#build/nuxt.config.mjs\";\nlet entry;\nif (import.meta.server) {\n  entry = async function createNuxtAppServer(ssrContext) {\n    const vueApp = createApp(RootComponent);\n    const nuxt = createNuxtApp({ vueApp, ssrContext });\n    try {\n      await applyPlugins(nuxt, plugins);\n      await nuxt.hooks.callHook(\"app:created\", vueApp);\n    } catch (error) {\n      await nuxt.hooks.callHook(\"app:error\", error);\n      nuxt.payload.error ||= createError(error);\n    }\n    if (ssrContext?._renderResponse) {\n      throw new Error(\"skipping render\");\n    }\n    return vueApp;\n  };\n}\nif (import.meta.client) {\n  if (import.meta.dev && import.meta.webpackHot) {\n    import.meta.webpackHot.accept();\n  }\n  let vueAppPromise;\n  entry = async function initApp() {\n    if (vueAppPromise) {\n      return vueAppPromise;\n    }\n    const isSSR = Boolean(\n      (multiApp ? window.__NUXT__?.[appId] : window.__NUXT__)?.serverRendered ?? (multiApp ? document.querySelector(`[data-nuxt-data=\"${appId}\"]`) : document.getElementById(\"__NUXT_DATA__\"))?.dataset.ssr === \"true\"\n    );\n    const vueApp = isSSR ? createSSRApp(RootComponent) : createApp(RootComponent);\n    const nuxt = createNuxtApp({ vueApp });\n    async function handleVueError(error) {\n      await nuxt.callHook(\"app:error\", error);\n      nuxt.payload.error ||= createError(error);\n    }\n    vueApp.config.errorHandler = handleVueError;\n    nuxt.hook(\"app:suspense:resolve\", () => {\n      if (vueApp.config.errorHandler === handleVueError) {\n        vueApp.config.errorHandler = void 0;\n      }\n    });\n    if (spaLoadingTemplateOutside && !isSSR && appSpaLoaderAttrs.id) {\n      nuxt.hook(\"app:suspense:resolve\", () => {\n        document.getElementById(appSpaLoaderAttrs.id)?.remove();\n      });\n    }\n    try {\n      await applyPlugins(nuxt, plugins);\n    } catch (err) {\n      handleVueError(err);\n    }\n    try {\n      await nuxt.hooks.callHook(\"app:created\", vueApp);\n      await nuxt.hooks.callHook(\"app:beforeMount\", vueApp);\n      vueApp.mount(vueAppRootContainer);\n      await nuxt.hooks.callHook(\"app:mounted\", vueApp);\n      await nextTick();\n    } catch (err) {\n      handleVueError(err);\n    }\n    return vueApp;\n  };\n  vueAppPromise = entry().catch((error) => {\n    console.error(\"Error while mounting app:\", error);\n    throw error;\n  });\n}\nexport default (ssrContext) => entry(ssrContext);\n"],"version":3}