{"file":"seo-ChMOT_fV.js","mappings":"gDAOO,MAAMA,EAAa,CAACC,EAAqBC,KACd,iBAATD,EAAoB,IAAIE,KAAKF,GAAQA,GAQ7CG,mBAAmB,QAAS,CALzCC,KAAM,UACNC,MAAO,OACPC,IAAK,aAG4DL,ICZxDM,EAAY,KACvB,MAAMC,EAASC,IAEf,MAAO,CACLC,QAASF,EAAOG,OAAOD,QACvBE,SAAUJ,EAAOG,OAAOC,SACxBC,aAAcL,EAAOG,OAAOE,aAC5BC,gBAAiBN,EAAOG,OAAOG,kBCQtBC,EAA0BC,IACrC,MAAMR,EAASC,IAEf,MAAO,CACL,WAAY,qBACZ,QAASO,EAAKC,MAAQ,UACtBC,KAAMF,EAAKG,MACXC,YAAaJ,EAAKI,YAClBC,IAAKL,EAAKK,KAAOb,EAAOG,OAAOD,QAC/BY,MAAON,EAAKM,MACZC,OAAQP,EAAKO,OAAS,CACpB,QAAS,SACTL,KAAMF,EAAKO,aACT,EACJC,UAAW,CACT,QAAS,eACTN,KAAMV,EAAOG,OAAOC,SACpBS,IAAKb,EAAOG,OAAOD,SAErBe,cAAeT,EAAKU,cACpBC,aAAcX,EAAKY,cAAgBZ,EAAKU,gBAO/BG,EAAoBb,IAC/B,MAAMR,EAASC,IACTqB,EAAUtB,EAAOG,OAAOD,QAE9B,MAAO,CAEL,CAAEQ,KAAM,cAAea,QAASf,EAAKI,aACrC,CAAEF,KAAM,WAAYa,QAASf,EAAKgB,UAAY,IAC9C,CAAEd,KAAM,SAAUa,QAASf,EAAKO,QAAUf,EAAOG,OAAOC,UAGxD,CAAEqB,SAAU,WAAYF,QAASf,EAAKG,OACtC,CAAEc,SAAU,iBAAkBF,QAASf,EAAKI,aAC5C,CAAEa,SAAU,UAAWF,QAASf,EAAKC,MAAQ,WAC7C,CAAEgB,SAAU,SAAUF,QAASf,EAAKK,KAAOS,GAC3C,CAAEG,SAAU,WAAYF,QAASf,EAAKM,OAAS,GAAGQ,kBAClD,CAAEG,SAAU,eAAgBF,QAASvB,EAAOG,OAAOC,UAGnD,CAAEM,KAAM,eAAgBa,QAAS,uBACjC,CAAEb,KAAM,gBAAiBa,QAASf,EAAKG,OACvC,CAAED,KAAM,sBAAuBa,QAASf,EAAKI,aAC7C,CAAEF,KAAM,gBAAiBa,QAASf,EAAKM,OAAS,GAAGQ,kBAGnD,CAAEZ,KAAM,SAAUa,QAAS,iBAC3B,CAAEb,KAAM,YAAaa,QAAS,iBAC9B,CAAE,aAAc,eAAgBA,QAAS,6BACzCG,OAAOC,GAAOA,EAAIJ,UAgCTK,EAAUpB,IACrB,MAAMqB,EAAQC,IAIRC,GA/B6BC,EA+BEH,EAAMG,KA3BpC,GAHQ/B,IACQE,OAAOD,QAAQ+B,QAAQ,MAAO,MACnCD,EAAKE,WAAW,KAAOF,EAAO,IAAIA,OAHlB,IAACA,EAkCnC,MAAMG,EAAe,IAChB3B,EACHK,IAAKL,EAAKK,KAAOkB,GAkBnB,OAdAK,EAAQ,CACNzB,MAAOH,EAAKG,MACZ0B,KAAMhB,EAAiBc,GACvBG,KAAM,CACJ,CAAEC,IAAK,YAAaC,KAAMT,IAE5BU,OAAQ,CACN,CACEhC,KAAM,sBACNiC,UAAWC,KAAKC,UAAUrC,EAAuB4B,QAKhD,CACLU,eAAgBtC,EAAuB4B,GACvCW,SAAUzB,EAAiBc,GAC3BY,aAAchB","names":["formatDate","date","options","Date","toLocaleDateString","year","month","day","useConfig","config","useRuntimeConfig","siteUrl","public","siteName","contactEmail","googleAnalytics","generateStructuredData","data","type","name","title","description","url","image","author","publisher","datePublished","publishedTime","dateModified","modifiedTime","generateMetaTags","baseUrl","content","keywords","property","filter","tag","useSEO","route","useRoute","fullUrl","path","replace","startsWith","enhancedData","useHead","meta","link","rel","href","script","innerHTML","JSON","stringify","structuredData","metaTags","canonicalUrl"],"sources":["../../../../utils/helpers.ts","../../../../composables/useConfig.ts","../../../../utils/seo.ts"],"sourcesContent":["/**\n * General utility helper functions\n */\n\n/**\n * Format date to human readable string\n */\nexport const formatDate = (date: string | Date, options?: Intl.DateTimeFormatOptions): string => {\n  const dateObj = typeof date === 'string' ? new Date(date) : date\n  \n  const defaultOptions: Intl.DateTimeFormatOptions = {\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric'\n  }\n  \n  return dateObj.toLocaleDateString('en-US', { ...defaultOptions, ...options })\n}\n\n/**\n * Calculate reading time for text content\n */\nexport const calculateReadingTime = (text: string, wordsPerMinute = 200): number => {\n  const words = text.trim().split(/\\s+/).length\n  return Math.ceil(words / wordsPerMinute)\n}\n\n/**\n * Generate slug from text\n */\nexport const generateSlug = (text: string): string => {\n  return text\n    .toLowerCase()\n    .trim()\n    .replace(/[^\\w\\s-]/g, '') // Remove special characters\n    .replace(/[\\s_-]+/g, '-') // Replace spaces and underscores with hyphens\n    .replace(/^-+|-+$/g, '') // Remove leading/trailing hyphens\n}\n\n/**\n * Truncate text with ellipsis\n */\nexport const truncateText = (text: string, maxLength: number, suffix = '...'): string => {\n  if (text.length <= maxLength) return text\n  return text.slice(0, maxLength - suffix.length) + suffix\n}\n\n/**\n * Capitalize first letter of each word\n */\nexport const titleCase = (text: string): string => {\n  return text.replace(/\\w\\S*/g, (txt) => \n    txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()\n  )\n}\n\n/**\n * Extract excerpt from HTML content\n */\nexport const extractExcerpt = (html: string, maxLength = 160): string => {\n  // Remove HTML tags\n  const text = html.replace(/<[^>]*>/g, '')\n  // Clean up whitespace\n  const cleaned = text.replace(/\\s+/g, ' ').trim()\n  return truncateText(cleaned, maxLength)\n}\n\n/**\n * Format file size to human readable format\n */\nexport const formatFileSize = (bytes: number): string => {\n  if (bytes === 0) return '0 Bytes'\n  \n  const k = 1024\n  const sizes = ['Bytes', 'KB', 'MB', 'GB']\n  const i = Math.floor(Math.log(bytes) / Math.log(k))\n  \n  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]\n}\n\n/**\n * Generate random ID\n */\nexport const generateId = (length = 8): string => {\n  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'\n  let result = ''\n  for (let i = 0; i < length; i++) {\n    result += chars.charAt(Math.floor(Math.random() * chars.length))\n  }\n  return result\n}\n\n/**\n * Deep clone object\n */\nexport const deepClone = <T>(obj: T): T => {\n  if (obj === null || typeof obj !== 'object') return obj\n  if (obj instanceof Date) return new Date(obj.getTime()) as unknown as T\n  if (obj instanceof Array) return obj.map(item => deepClone(item)) as unknown as T\n  if (typeof obj === 'object') {\n    const clonedObj = {} as { [key: string]: any }\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        clonedObj[key] = deepClone(obj[key])\n      }\n    }\n    return clonedObj as T\n  }\n  return obj\n}\n\n/**\n * Check if object is empty\n */\nexport const isEmpty = (obj: any): boolean => {\n  if (obj == null) return true\n  if (Array.isArray(obj) || typeof obj === 'string') return obj.length === 0\n  if (typeof obj === 'object') return Object.keys(obj).length === 0\n  return false\n}\n\n/**\n * Merge objects deeply\n */\nexport const deepMerge = <T extends Record<string, any>>(target: T, ...sources: Partial<T>[]): T => {\n  if (!sources.length) return target\n  const source = sources.shift()\n  \n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) Object.assign(target, { [key]: {} })\n        deepMerge(target[key], source[key])\n      } else {\n        Object.assign(target, { [key]: source[key] })\n      }\n    }\n  }\n  \n  return deepMerge(target, ...sources)\n}\n\n/**\n * Check if value is object\n */\nconst isObject = (item: any): boolean => {\n  return item && typeof item === 'object' && !Array.isArray(item)\n}\n\n/**\n * Format currency\n */\nexport const formatCurrency = (\n  amount: number, \n  currency = 'USD', \n  locale = 'en-US'\n): string => {\n  return new Intl.NumberFormat(locale, {\n    style: 'currency',\n    currency\n  }).format(amount)\n}\n\n/**\n * Format number with commas\n */\nexport const formatNumber = (num: number, locale = 'en-US'): string => {\n  return new Intl.NumberFormat(locale).format(num)\n}\n\n/**\n * Get initials from name\n */\nexport const getInitials = (name: string): string => {\n  return name\n    .split(' ')\n    .map(word => word.charAt(0).toUpperCase())\n    .join('')\n    .slice(0, 2)\n}\n\n/**\n * Validate email format\n */\nexport const isValidEmail = (email: string): boolean => {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\n  return emailRegex.test(email)\n}\n\n/**\n * Validate URL format\n */\nexport const isValidUrl = (url: string): boolean => {\n  try {\n    new URL(url)\n    return true\n  } catch {\n    return false\n  }\n}\n\n/**\n * Get contrast color (black or white) for background\n */\nexport const getContrastColor = (hexColor: string): string => {\n  // Remove # if present\n  const hex = hexColor.replace('#', '')\n  \n  // Convert to RGB\n  const r = parseInt(hex.substr(0, 2), 16)\n  const g = parseInt(hex.substr(2, 2), 16)\n  const b = parseInt(hex.substr(4, 2), 16)\n  \n  // Calculate luminance\n  const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255\n  \n  return luminance > 0.5 ? '#000000' : '#ffffff'\n}\n\n/**\n * Sleep function for async operations\n */\nexport const sleep = (ms: number): Promise<void> => {\n  return new Promise(resolve => setTimeout(resolve, ms))\n}\n\n/**\n * Retry function with exponential backoff\n */\nexport const retry = async <T>(\n  fn: () => Promise<T>,\n  maxAttempts = 3,\n  baseDelay = 1000\n): Promise<T> => {\n  let lastError: Error\n  \n  for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n    try {\n      return await fn()\n    } catch (error) {\n      lastError = error as Error\n      \n      if (attempt === maxAttempts) {\n        throw lastError\n      }\n      \n      const delay = baseDelay * Math.pow(2, attempt - 1)\n      await sleep(delay)\n    }\n  }\n  \n  throw lastError!\n}\n","/**\n * Site configuration composable\n * Provides centralized access to runtime configuration\n */\nexport const useConfig = () => {\n  const config = useRuntimeConfig()\n\n  return {\n    siteUrl: config.public.siteUrl,\n    siteName: config.public.siteName,\n    contactEmail: config.public.contactEmail,\n    googleAnalytics: config.public.googleAnalytics\n  }\n}\n","/**\n * SEO optimization utilities\n */\n\nexport interface SEOData {\n  title: string\n  description: string\n  keywords?: string\n  image?: string\n  url?: string\n  type?: string\n  author?: string\n  publishedTime?: string\n  modifiedTime?: string\n}\n\n/**\n * Generate structured data for SEO\n */\nexport const generateStructuredData = (data: SEOData) => {\n  const config = useRuntimeConfig()\n  \n  return {\n    '@context': 'https://schema.org',\n    '@type': data.type || 'WebPage',\n    name: data.title,\n    description: data.description,\n    url: data.url || config.public.siteUrl,\n    image: data.image,\n    author: data.author ? {\n      '@type': 'Person',\n      name: data.author\n    } : undefined,\n    publisher: {\n      '@type': 'Organization',\n      name: config.public.siteName,\n      url: config.public.siteUrl\n    },\n    datePublished: data.publishedTime,\n    dateModified: data.modifiedTime || data.publishedTime\n  }\n}\n\n/**\n * Generate meta tags for SEO\n */\nexport const generateMetaTags = (data: SEOData) => {\n  const config = useRuntimeConfig()\n  const baseUrl = config.public.siteUrl\n  \n  return [\n    // Basic meta tags\n    { name: 'description', content: data.description },\n    { name: 'keywords', content: data.keywords || '' },\n    { name: 'author', content: data.author || config.public.siteName },\n    \n    // Open Graph tags\n    { property: 'og:title', content: data.title },\n    { property: 'og:description', content: data.description },\n    { property: 'og:type', content: data.type || 'website' },\n    { property: 'og:url', content: data.url || baseUrl },\n    { property: 'og:image', content: data.image || `${baseUrl}/og-image.jpg` },\n    { property: 'og:site_name', content: config.public.siteName },\n    \n    // Twitter Card tags\n    { name: 'twitter:card', content: 'summary_large_image' },\n    { name: 'twitter:title', content: data.title },\n    { name: 'twitter:description', content: data.description },\n    { name: 'twitter:image', content: data.image || `${baseUrl}/og-image.jpg` },\n    \n    // Additional SEO tags\n    { name: 'robots', content: 'index, follow' },\n    { name: 'googlebot', content: 'index, follow' },\n    { 'http-equiv': 'Content-Type', content: 'text/html; charset=utf-8' }\n  ].filter(tag => tag.content) // Remove empty content tags\n}\n\n/**\n * Generate canonical URL\n */\nexport const generateCanonicalUrl = (path: string) => {\n  const config = useRuntimeConfig()\n  const baseUrl = config.public.siteUrl.replace(/\\/$/, '')\n  const cleanPath = path.startsWith('/') ? path : `/${path}`\n  return `${baseUrl}${cleanPath}`\n}\n\n/**\n * Generate breadcrumb structured data\n */\nexport const generateBreadcrumbData = (items: Array<{ name: string; url: string }>) => {\n  return {\n    '@context': 'https://schema.org',\n    '@type': 'BreadcrumbList',\n    itemListElement: items.map((item, index) => ({\n      '@type': 'ListItem',\n      position: index + 1,\n      name: item.name,\n      item: item.url\n    }))\n  }\n}\n\n/**\n * SEO composable for pages\n */\nexport const useSEO = (data: SEOData) => {\n  const route = useRoute()\n  const config = useRuntimeConfig()\n  \n  // Generate full URL\n  const fullUrl = generateCanonicalUrl(route.path)\n  \n  // Enhanced SEO data\n  const enhancedData = {\n    ...data,\n    url: data.url || fullUrl\n  }\n  \n  // Set page meta\n  useHead({\n    title: data.title,\n    meta: generateMetaTags(enhancedData),\n    link: [\n      { rel: 'canonical', href: fullUrl }\n    ],\n    script: [\n      {\n        type: 'application/ld+json',\n        innerHTML: JSON.stringify(generateStructuredData(enhancedData))\n      }\n    ]\n  })\n  \n  return {\n    structuredData: generateStructuredData(enhancedData),\n    metaTags: generateMetaTags(enhancedData),\n    canonicalUrl: fullUrl\n  }\n}\n"],"version":3}