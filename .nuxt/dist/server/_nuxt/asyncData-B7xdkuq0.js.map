{"version":3,"file":"asyncData-B7xdkuq0.js","sources":["../../../../node_modules/nuxt/dist/app/composables/asyncData.js"],"sourcesContent":["import { computed, getCurrentInstance, getCurrentScope, inject, isShallow, nextTick, onBeforeMount, onScopeDispose, onServerPrefetch, onUnmounted, ref, shallowRef, toRef, toValue, unref, watch } from \"vue\";\nimport { debounce } from \"perfect-debounce\";\nimport { hash } from \"ohash\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { getUserCaller, toArray } from \"../utils.js\";\nimport { clientOnlySymbol } from \"../components/client-only.js\";\nimport { createError } from \"./error.js\";\nimport { onNuxtReady } from \"./ready.js\";\nimport { asyncDataDefaults, granularCachedData, pendingWhenIdle, purgeCachedData, resetAsyncDataToUndefined } from \"#build/nuxt.config.mjs\";\nconst isDefer = (dedupe) => dedupe === \"defer\" || dedupe === false;\nexport function useAsyncData(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (_isAutoKeyNeeded(args[0], args[1])) {\n    args.unshift(autoKey);\n  }\n  let [_key, _handler, options = {}] = args;\n  const key = computed(() => toValue(_key));\n  if (typeof key.value !== \"string\") {\n    throw new TypeError(\"[nuxt] [useAsyncData] key must be a string.\");\n  }\n  if (typeof _handler !== \"function\") {\n    throw new TypeError(\"[nuxt] [useAsyncData] handler must be a function.\");\n  }\n  const nuxtApp = useNuxtApp();\n  options.server ??= true;\n  options.default ??= getDefault;\n  options.getCachedData ??= getDefaultCachedData;\n  options.lazy ??= false;\n  options.immediate ??= true;\n  options.deep ??= asyncDataDefaults.deep;\n  options.dedupe ??= \"cancel\";\n  const functionName = options._functionName || \"useAsyncData\";\n  if (import.meta.dev && typeof options.dedupe === \"boolean\") {\n    console.warn(`[nuxt] \\`boolean\\` values are deprecated for the \\`dedupe\\` option of \\`${functionName}\\` and will be removed in the future. Use 'cancel' or 'defer' instead.`);\n  }\n  const currentData = nuxtApp._asyncData[key.value];\n  if (import.meta.dev && currentData) {\n    const warnings = [];\n    const values = createHash(_handler, options);\n    if (values.handler !== currentData._hash?.handler) {\n      warnings.push(`different handler`);\n    }\n    for (const opt of [\"transform\", \"pick\", \"getCachedData\"]) {\n      if (values[opt] !== currentData._hash[opt]) {\n        warnings.push(`different \\`${opt}\\` option`);\n      }\n    }\n    if (currentData._default.toString() !== options.default.toString()) {\n      warnings.push(`different \\`default\\` value`);\n    }\n    if (options.deep && isShallow(currentData.data)) {\n      warnings.push(`mismatching \\`deep\\` option`);\n    }\n    if (warnings.length) {\n      const caller = getUserCaller();\n      const explanation = caller ? ` (used at ${caller.source}:${caller.line}:${caller.column})` : \"\";\n      console.warn(`[nuxt] [${functionName}] Incompatible options detected for \"${key.value}\"${explanation}:\n${warnings.map((w) => `- ${w}`).join(\"\\n\")}\nYou can use a different key or move the call to a composable to ensure the options are shared across calls.`);\n    }\n  }\n  const initialFetchOptions = { cause: \"initial\", dedupe: options.dedupe };\n  if (!nuxtApp._asyncData[key.value]?._init) {\n    initialFetchOptions.cachedData = options.getCachedData(key.value, nuxtApp, { cause: \"initial\" });\n    nuxtApp._asyncData[key.value] = createAsyncData(nuxtApp, key.value, _handler, options, initialFetchOptions.cachedData);\n  }\n  const asyncData = nuxtApp._asyncData[key.value];\n  asyncData._deps++;\n  const initialFetch = () => nuxtApp._asyncData[key.value].execute(initialFetchOptions);\n  const fetchOnServer = options.server !== false && nuxtApp.payload.serverRendered;\n  if (import.meta.server && fetchOnServer && options.immediate) {\n    const promise = initialFetch();\n    if (getCurrentInstance()) {\n      onServerPrefetch(() => promise);\n    } else {\n      nuxtApp.hook(\"app:created\", async () => {\n        await promise;\n      });\n    }\n  }\n  if (import.meta.client) {\n    let unregister = function(key2) {\n      const data = nuxtApp._asyncData[key2];\n      if (data?._deps) {\n        data._deps--;\n        if (data._deps === 0) {\n          data?._off();\n        }\n      }\n    };\n    const instance = getCurrentInstance();\n    if (instance && fetchOnServer && options.immediate && !instance.sp) {\n      instance.sp = [];\n    }\n    if (import.meta.dev && !nuxtApp.isHydrating && !nuxtApp._processingMiddleware && (!instance || instance?.isMounted)) {\n      console.warn(`[nuxt] [${functionName}] Component is already mounted, please use $fetch instead. See https://nuxt.com/docs/getting-started/data-fetching`);\n    }\n    if (instance && !instance._nuxtOnBeforeMountCbs) {\n      instance._nuxtOnBeforeMountCbs = [];\n      const cbs = instance._nuxtOnBeforeMountCbs;\n      onBeforeMount(() => {\n        cbs.forEach((cb) => {\n          cb();\n        });\n        cbs.splice(0, cbs.length);\n      });\n      onUnmounted(() => cbs.splice(0, cbs.length));\n    }\n    const isWithinClientOnly = instance && (instance._nuxtClientOnly || inject(clientOnlySymbol, false));\n    if (fetchOnServer && nuxtApp.isHydrating && (asyncData.error.value || asyncData.data.value != null)) {\n      if (pendingWhenIdle) {\n        asyncData.pending.value = false;\n      }\n      asyncData.status.value = asyncData.error.value ? \"error\" : \"success\";\n    } else if (instance && (!isWithinClientOnly && nuxtApp.payload.serverRendered && nuxtApp.isHydrating || options.lazy) && options.immediate) {\n      instance._nuxtOnBeforeMountCbs.push(initialFetch);\n    } else if (options.immediate) {\n      initialFetch();\n    }\n    const hasScope = getCurrentScope();\n    const unsubKeyWatcher = watch(key, (newKey, oldKey) => {\n      if ((newKey || oldKey) && newKey !== oldKey) {\n        const hasRun = nuxtApp._asyncData[oldKey]?.data.value !== asyncDataDefaults.value;\n        const isRunning = nuxtApp._asyncDataPromises[oldKey] !== void 0;\n        if (oldKey) {\n          unregister(oldKey);\n        }\n        const initialFetchOptions2 = { cause: \"initial\", dedupe: options.dedupe };\n        if (!nuxtApp._asyncData[newKey]?._init) {\n          let value;\n          if (oldKey && hasRun) {\n            value = nuxtApp._asyncData[oldKey]?.data.value;\n          } else {\n            value = options.getCachedData(newKey, nuxtApp, { cause: \"initial\" });\n            initialFetchOptions2.cachedData = value;\n          }\n          nuxtApp._asyncData[newKey] = createAsyncData(nuxtApp, newKey, _handler, options, value);\n        }\n        nuxtApp._asyncData[newKey]._deps++;\n        if (options.immediate || hasRun || isRunning) {\n          nuxtApp._asyncData[newKey].execute(initialFetchOptions2);\n        }\n      }\n    }, { flush: \"sync\" });\n    const unsubWatcher = options.watch ? watch(options.watch, () => {\n      asyncData._execute({ cause: \"watch\", dedupe: options.dedupe });\n    }) : () => {\n    };\n    if (hasScope) {\n      onScopeDispose(() => {\n        unsubKeyWatcher();\n        unsubWatcher();\n        unregister(key.value);\n      });\n    }\n  }\n  const asyncReturn = {\n    data: writableComputedRef(() => nuxtApp._asyncData[key.value]?.data),\n    pending: writableComputedRef(() => nuxtApp._asyncData[key.value]?.pending),\n    status: writableComputedRef(() => nuxtApp._asyncData[key.value]?.status),\n    error: writableComputedRef(() => nuxtApp._asyncData[key.value]?.error),\n    refresh: (...args2) => nuxtApp._asyncData[key.value].execute(...args2),\n    execute: (...args2) => nuxtApp._asyncData[key.value].execute(...args2),\n    clear: () => clearNuxtDataByKey(nuxtApp, key.value)\n  };\n  const asyncDataPromise = Promise.resolve(nuxtApp._asyncDataPromises[key.value]).then(() => asyncReturn);\n  Object.assign(asyncDataPromise, asyncReturn);\n  return asyncDataPromise;\n}\nfunction writableComputedRef(getter) {\n  return computed({\n    get() {\n      return getter()?.value;\n    },\n    set(value) {\n      const ref2 = getter();\n      if (ref2) {\n        ref2.value = value;\n      }\n    }\n  });\n}\nexport function useLazyAsyncData(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (_isAutoKeyNeeded(args[0], args[1])) {\n    args.unshift(autoKey);\n  }\n  const [key, handler, options = {}] = args;\n  if (import.meta.dev) {\n    options._functionName ||= \"useLazyAsyncData\";\n  }\n  return useAsyncData(key, handler, { ...options, lazy: true }, null);\n}\nfunction _isAutoKeyNeeded(keyOrFetcher, fetcher) {\n  if (typeof keyOrFetcher === \"string\") {\n    return false;\n  }\n  if (typeof keyOrFetcher === \"object\" && keyOrFetcher !== null) {\n    return false;\n  }\n  if (typeof keyOrFetcher === \"function\" && typeof fetcher === \"function\") {\n    return false;\n  }\n  return true;\n}\nexport function useNuxtData(key) {\n  const nuxtApp = useNuxtApp();\n  if (!(key in nuxtApp.payload.data)) {\n    nuxtApp.payload.data[key] = asyncDataDefaults.value;\n  }\n  if (nuxtApp._asyncData[key]) {\n    const data = nuxtApp._asyncData[key];\n    data._deps++;\n    if (getCurrentScope()) {\n      onScopeDispose(() => {\n        data._deps--;\n        if (data._deps === 0) {\n          data?._off();\n        }\n      });\n    }\n  }\n  return {\n    data: computed({\n      get() {\n        return nuxtApp._asyncData[key]?.data.value ?? nuxtApp.payload.data[key];\n      },\n      set(value) {\n        if (nuxtApp._asyncData[key]) {\n          nuxtApp._asyncData[key].data.value = value;\n        } else {\n          nuxtApp.payload.data[key] = value;\n        }\n      }\n    })\n  };\n}\nexport async function refreshNuxtData(keys) {\n  if (import.meta.server) {\n    return Promise.resolve();\n  }\n  await new Promise((resolve) => onNuxtReady(resolve));\n  const _keys = keys ? toArray(keys) : void 0;\n  await useNuxtApp().hooks.callHookParallel(\"app:data:refresh\", _keys);\n}\nexport function clearNuxtData(keys) {\n  const nuxtApp = useNuxtApp();\n  const _allKeys = Object.keys(nuxtApp.payload.data);\n  const _keys = !keys ? _allKeys : typeof keys === \"function\" ? _allKeys.filter(keys) : toArray(keys);\n  for (const key of _keys) {\n    clearNuxtDataByKey(nuxtApp, key);\n  }\n}\nfunction clearNuxtDataByKey(nuxtApp, key) {\n  if (key in nuxtApp.payload.data) {\n    nuxtApp.payload.data[key] = void 0;\n  }\n  if (key in nuxtApp.payload._errors) {\n    nuxtApp.payload._errors[key] = asyncDataDefaults.errorValue;\n  }\n  if (nuxtApp._asyncData[key]) {\n    nuxtApp._asyncData[key].data.value = resetAsyncDataToUndefined ? void 0 : unref(nuxtApp._asyncData[key]._default());\n    nuxtApp._asyncData[key].error.value = asyncDataDefaults.errorValue;\n    if (pendingWhenIdle) {\n      nuxtApp._asyncData[key].pending.value = false;\n    }\n    nuxtApp._asyncData[key].status.value = \"idle\";\n  }\n  if (key in nuxtApp._asyncDataPromises) {\n    if (nuxtApp._asyncDataPromises[key]) {\n      nuxtApp._asyncDataPromises[key].cancelled = true;\n    }\n    nuxtApp._asyncDataPromises[key] = void 0;\n  }\n}\nfunction pick(obj, keys) {\n  const newObj = {};\n  for (const key of keys) {\n    newObj[key] = obj[key];\n  }\n  return newObj;\n}\nfunction createAsyncData(nuxtApp, key, _handler, options, initialCachedData) {\n  nuxtApp.payload._errors[key] ??= asyncDataDefaults.errorValue;\n  const hasCustomGetCachedData = options.getCachedData !== getDefaultCachedData;\n  const handler = import.meta.client || !import.meta.prerender || !nuxtApp.ssrContext?._sharedPrerenderCache ? _handler : () => {\n    const value = nuxtApp.ssrContext._sharedPrerenderCache.get(key);\n    if (value) {\n      return value;\n    }\n    const promise = Promise.resolve().then(() => nuxtApp.runWithContext(() => _handler(nuxtApp)));\n    nuxtApp.ssrContext._sharedPrerenderCache.set(key, promise);\n    return promise;\n  };\n  const _ref = options.deep ? ref : shallowRef;\n  const hasCachedData = initialCachedData != null;\n  const unsubRefreshAsyncData = nuxtApp.hook(\"app:data:refresh\", async (keys) => {\n    if (!keys || keys.includes(key)) {\n      await asyncData.execute({ cause: \"refresh:hook\" });\n    }\n  });\n  const asyncData = {\n    data: _ref(hasCachedData ? initialCachedData : options.default()),\n    pending: pendingWhenIdle ? shallowRef(!hasCachedData) : computed(() => asyncData.status.value === \"pending\"),\n    error: toRef(nuxtApp.payload._errors, key),\n    status: shallowRef(\"idle\"),\n    execute: (...args) => {\n      const [_opts, newValue = void 0] = args;\n      const opts = _opts && newValue === void 0 && typeof _opts === \"object\" ? _opts : {};\n      if (import.meta.dev && newValue !== void 0 && (!_opts || typeof _opts !== \"object\")) {\n        console.warn(`[nuxt] [${options._functionName}] Do not pass \\`execute\\` directly to \\`watch\\`. Instead, use an inline function, such as \\`watch(q, () => execute())\\`.`);\n      }\n      if (nuxtApp._asyncDataPromises[key]) {\n        if (isDefer(opts.dedupe ?? options.dedupe)) {\n          return nuxtApp._asyncDataPromises[key];\n        }\n        nuxtApp._asyncDataPromises[key].cancelled = true;\n      }\n      if (granularCachedData || opts.cause === \"initial\" || nuxtApp.isHydrating) {\n        const cachedData = \"cachedData\" in opts ? opts.cachedData : options.getCachedData(key, nuxtApp, { cause: opts.cause ?? \"refresh:manual\" });\n        if (cachedData != null) {\n          nuxtApp.payload.data[key] = asyncData.data.value = cachedData;\n          asyncData.error.value = asyncDataDefaults.errorValue;\n          asyncData.status.value = \"success\";\n          return Promise.resolve(cachedData);\n        }\n      }\n      if (pendingWhenIdle) {\n        asyncData.pending.value = true;\n      }\n      asyncData.status.value = \"pending\";\n      const promise = new Promise(\n        (resolve, reject) => {\n          try {\n            resolve(handler(nuxtApp));\n          } catch (err) {\n            reject(err);\n          }\n        }\n      ).then(async (_result) => {\n        if (promise.cancelled) {\n          return nuxtApp._asyncDataPromises[key];\n        }\n        let result = _result;\n        if (options.transform) {\n          result = await options.transform(_result);\n        }\n        if (options.pick) {\n          result = pick(result, options.pick);\n        }\n        if (import.meta.dev && import.meta.server && result == null) {\n          const caller = getUserCaller();\n          const explanation = caller ? ` (used at ${caller.source}:${caller.line}:${caller.column})` : \"\";\n          console.warn(`[nuxt] \\`${options._functionName || \"useAsyncData\"}${explanation}\\` must return a value (it should not be \\`undefined\\` or \\`null\\`) or the request may be duplicated on the client side.`);\n        }\n        nuxtApp.payload.data[key] = result;\n        asyncData.data.value = result;\n        asyncData.error.value = asyncDataDefaults.errorValue;\n        asyncData.status.value = \"success\";\n      }).catch((error) => {\n        if (promise.cancelled) {\n          return nuxtApp._asyncDataPromises[key];\n        }\n        asyncData.error.value = createError(error);\n        asyncData.data.value = unref(options.default());\n        asyncData.status.value = \"error\";\n      }).finally(() => {\n        if (promise.cancelled) {\n          return;\n        }\n        if (pendingWhenIdle) {\n          asyncData.pending.value = false;\n        }\n        delete nuxtApp._asyncDataPromises[key];\n      });\n      nuxtApp._asyncDataPromises[key] = promise;\n      return nuxtApp._asyncDataPromises[key];\n    },\n    _execute: debounce((...args) => asyncData.execute(...args), 0, { leading: true }),\n    _default: options.default,\n    _deps: 0,\n    _init: true,\n    _hash: import.meta.dev ? createHash(_handler, options) : void 0,\n    _off: () => {\n      unsubRefreshAsyncData();\n      if (nuxtApp._asyncData[key]?._init) {\n        nuxtApp._asyncData[key]._init = false;\n      }\n      if (purgeCachedData && !hasCustomGetCachedData) {\n        nextTick(() => {\n          if (!nuxtApp._asyncData[key]?._init) {\n            clearNuxtDataByKey(nuxtApp, key);\n            asyncData.execute = () => Promise.resolve();\n            asyncData.data.value = asyncDataDefaults.value;\n          }\n        });\n      }\n    }\n  };\n  return asyncData;\n}\nconst getDefault = () => asyncDataDefaults.value;\nconst getDefaultCachedData = (key, nuxtApp, ctx) => {\n  if (nuxtApp.isHydrating) {\n    return nuxtApp.payload.data[key];\n  }\n  if (ctx.cause !== \"refresh:manual\" && ctx.cause !== \"refresh:hook\") {\n    return nuxtApp.static.data[key];\n  }\n};\nfunction createHash(_handler, options) {\n  return {\n    handler: hash(_handler),\n    transform: options.transform ? hash(options.transform) : void 0,\n    pick: options.pick ? hash(options.pick) : void 0,\n    getCachedData: options.getCachedData ? hash(options.getCachedData) : void 0\n  };\n}\n"],"names":["useAsyncData","args","autoKey","length","pop","keyOrFetcher","fetcher","_isAutoKeyNeeded","unshift","_key","_handler","options","key","computed","toValue","value","TypeError","nuxtApp","useNuxtApp","server","default","getDefault","getCachedData","getDefaultCachedData","lazy","immediate","deep","asyncDataDefaults","dedupe","_functionName","_asyncData","initialFetchOptions","cause","_init","cachedData","initialCachedData","payload","_errors","errorValue","hasCustomGetCachedData","handler","prerender","ssrContext","_sharedPrerenderCache","get","promise","Promise","resolve","then","runWithContext","set","_ref","ref","shallowRef","hasCachedData","unsubRefreshAsyncData","hook","async","keys","includes","asyncData","execute","data","pending","error","toRef","status","_opts","newValue","opts","_asyncDataPromises","cancelled","isHydrating","reject","err","_result","result","transform","pick","obj","newObj","catch","createError","unref","finally","_execute","debounce","leading","_default","_deps","_hash","_off","nextTick","clearNuxtDataByKey","createAsyncData","serverRendered","getCurrentInstance","onServerPrefetch","asyncReturn","writableComputedRef","refresh","args2","clear","asyncDataPromise","Object","assign","getter","ref2","ctx","static"],"mappings":"kWAUO,SAASA,KAAgBC,GAC9B,MAAMC,EAA2C,iBAA1BD,EAAKA,EAAKE,OAAS,GAAkBF,EAAKG,WAAQ,GAsL3E,SAA0BC,EAAcC,GACtC,GAA4B,iBAAjBD,EACT,OAAO,EAET,GAA4B,iBAAjBA,GAA8C,OAAjBA,EACtC,OAAO,EAET,GAA4B,mBAAjBA,GAAkD,mBAAZC,EAC/C,OAAO,EAET,OAAO,CACT,EAhMMC,CAAiBN,EAAK,GAAIA,EAAK,KACjCA,EAAKO,QAAQN,GAEf,IAAKO,EAAMC,EAAUC,EAAU,CAAA,GAAMV,EACrC,MAAMW,EAAMC,EAAS,IAAMC,EAAQL,IACnC,GAAyB,iBAAdG,EAAIG,MACb,MAAM,IAAIC,UAAU,+CAEtB,GAAwB,mBAAbN,EACT,MAAM,IAAIM,UAAU,qDAEtB,MAAMC,EAAUC,IAChBP,EAAQQ,UAAW,EACnBR,EAAQS,UAAYC,EACpBV,EAAQW,gBAAkBC,EAC1BZ,EAAQa,QAAS,EACjBb,EAAQc,aAAc,EACtBd,EAAQe,OAASC,EAAkBD,KACnCf,EAAQiB,SAAW,SACEjB,EAAQkB,cAITZ,EAAQa,WAAWlB,EAAIG,OA0B3C,MAAMgB,EAAsB,CAAEC,MAAO,UAAWJ,OAAQjB,EAAQiB,QAC3DX,EAAQa,WAAWlB,EAAIG,QAAQkB,QAClCF,EAAoBG,WAAavB,EAAQW,cAAcV,EAAIG,MAAOE,EAAS,CAAEe,MAAO,YACpFf,EAAQa,WAAWlB,EAAIG,OA0N3B,SAAyBE,EAASL,EAAKF,EAAUC,EAASwB,GACxDlB,EAAQmB,QAAQC,QAAQzB,KAASe,EAAkBW,WACnD,MAAMC,EAAyB5B,EAAQW,gBAAkBC,EACnDiB,cAA6CC,WAAcxB,EAAQyB,YAAYC,sBAAmC,KACtH,MAAM5B,EAAQE,EAAQyB,WAAWC,sBAAsBC,IAAIhC,GAC3D,GAAIG,EACF,OAAOA,EAET,MAAM8B,EAAUC,QAAQC,UAAUC,KAAK,IAAM/B,EAAQgC,eAAe,IAAMvC,EAASO,KAEnF,OADAA,EAAQyB,WAAWC,sBAAsBO,IAAItC,EAAKiC,GAC3CA,GAPoGnC,EASvGyC,EAAOxC,EAAQe,KAAO0B,EAAMC,EAC5BC,EAAqC,MAArBnB,EAChBoB,EAAwBtC,EAAQuC,KAAK,mBAAoBC,MAAOC,IAC/DA,IAAQA,EAAKC,SAAS/C,UACnBgD,EAAUC,QAAQ,CAAE7B,MAAO,mBAG/B4B,EAAY,CAChBE,KAAMX,EAAKG,EAAgBnB,EAAoBxB,EAAQS,WACvD2C,QAA2BV,GAAYC,GACvCU,MAAOC,EAAMhD,EAAQmB,QAAQC,QAASzB,GACtCsD,OAAQb,EAAW,QACnBQ,QAAS,IAAI5D,KACX,MAAOkE,EAAOC,GAAqBnE,EAC7BoE,EAAOF,QAAsB,IAAbC,GAAwC,iBAAVD,EAAqBA,EAAQ,CAAA,EAIjF,GAAIlD,EAAQqD,mBAAmB1D,GAAM,CACnC,GAhT+B,WAAtBgB,EAgTGyC,EAAKzC,QAAUjB,EAAQiB,UAhTkB,IAAXA,EAiTxC,OAAOX,EAAQqD,mBAAmB1D,GAEpCK,EAAQqD,mBAAmB1D,GAAK2D,WAAY,CAC9C,CApTU,IAAC3C,EAqTX,GAAyC,YAAfyC,EAAKrC,OAAuBf,EAAQuD,YAAa,CACzE,MAAMtC,EAAa,eAAgBmC,EAAOA,EAAKnC,WAAavB,EAAQW,cAAcV,EAAKK,EAAS,CAAEe,MAAOqC,EAAKrC,OAAS,mBACvH,GAAkB,MAAdE,EAIF,OAHAjB,EAAQmB,QAAQ0B,KAAKlD,GAAOgD,EAAUE,KAAK/C,MAAQmB,EACnD0B,EAAUI,MAAMjD,MAAQY,EAAkBW,WAC1CsB,EAAUM,OAAOnD,MAAQ,UAClB+B,QAAQC,QAAQb,EAE3B,CAEE0B,EAAUG,QAAQhD,OAAQ,EAE5B6C,EAAUM,OAAOnD,MAAQ,UACzB,MAAM8B,EAAU,IAAIC,QAClB,CAACC,EAAS0B,KACR,IACE1B,EAAQP,EAAQvB,GAClB,OAASyD,GACPD,EAAOC,EACT,IAEF1B,KAAKS,MAAOkB,IACZ,GAAI9B,EAAQ0B,UACV,OAAOtD,EAAQqD,mBAAmB1D,GAEpC,IAAIgE,EAASD,EACThE,EAAQkE,YACVD,QAAejE,EAAQkE,UAAUF,IAE/BhE,EAAQmE,OACVF,EAzEV,SAAcG,EAAKrB,GACjB,MAAMsB,EAAS,CAAA,EACf,IAAA,MAAWpE,KAAO8C,EAChBsB,EAAOpE,GAAOmE,EAAInE,GAEpB,OAAOoE,CACT,CAmEmBF,CAAKF,EAAQjE,EAAQmE,OAOhC7D,EAAQmB,QAAQ0B,KAAKlD,GAAOgE,EAC5BhB,EAAUE,KAAK/C,MAAQ6D,EACvBhB,EAAUI,MAAMjD,MAAQY,EAAkBW,WAC1CsB,EAAUM,OAAOnD,MAAQ,YACxBkE,MAAOjB,IACR,GAAInB,EAAQ0B,UACV,OAAOtD,EAAQqD,mBAAmB1D,GAEpCgD,EAAUI,MAAMjD,MAAQmE,EAAYlB,GACpCJ,EAAUE,KAAK/C,MAAQoE,EAAMxE,EAAQS,WACrCwC,EAAUM,OAAOnD,MAAQ,UACxBqE,QAAQ,KACLvC,EAAQ0B,YAIVX,EAAUG,QAAQhD,OAAQ,SAErBE,EAAQqD,mBAAmB1D,MAGpC,OADAK,EAAQqD,mBAAmB1D,GAAOiC,EAC3B5B,EAAQqD,mBAAmB1D,IAEpCyE,SAAUC,EAAS,IAAIrF,IAAS2D,EAAUC,WAAW5D,GAAO,EAAG,CAAEsF,SAAS,IAC1EC,SAAU7E,EAAQS,QAClBqE,MAAO,EACPxD,OAAO,EACPyD,WAAyD,EACzDC,KAAM,KACJpC,IACItC,EAAQa,WAAWlB,IAAMqB,QAC3BhB,EAAQa,WAAWlB,GAAKqB,OAAQ,GAEVM,GACtBqD,EAAS,KACF3E,EAAQa,WAAWlB,IAAMqB,QAC5B4D,EAAmB5E,EAASL,GAC5BgD,EAAUC,QAAU,IAAMf,QAAQC,UAClCa,EAAUE,KAAK/C,MAAQY,EAAkBZ,WAMnD,OAAO6C,CACT,CAhVoCkC,CAAgB7E,EAASL,EAAIG,MAAOL,EAAUC,EAASoB,EAAoBG,aAE3FjB,EAAQa,WAAWlB,EAAIG,OAC/B0E,QAGV,IADyC,IAAnB9E,EAAQQ,QAAoBF,EAAQmB,QAAQ2D,gBACvBpF,EAAQc,UAAW,CAC5D,MAAMoB,EAHmB5B,EAAQa,WAAWlB,EAAIG,OAAO8C,QAAQ9B,GAI3DiE,IACFC,EAAiB,IAAMpD,GAEvB5B,EAAQuC,KAAK,cAAeC,gBACpBZ,GAGZ,CA6EA,MAAMqD,EAAc,CAClBpC,KAAMqC,EAAoB,IAAMlF,EAAQa,WAAWlB,EAAIG,QAAQ+C,MAC/DC,QAASoC,EAAoB,IAAMlF,EAAQa,WAAWlB,EAAIG,QAAQgD,SAClEG,OAAQiC,EAAoB,IAAMlF,EAAQa,WAAWlB,EAAIG,QAAQmD,QACjEF,MAAOmC,EAAoB,IAAMlF,EAAQa,WAAWlB,EAAIG,QAAQiD,OAChEoC,QAAS,IAAIC,IAAUpF,EAAQa,WAAWlB,EAAIG,OAAO8C,WAAWwC,GAChExC,QAAS,IAAIwC,IAAUpF,EAAQa,WAAWlB,EAAIG,OAAO8C,WAAWwC,GAChEC,MAAO,IAAMT,EAAmB5E,EAASL,EAAIG,QAEzCwF,EAAmBzD,QAAQC,QAAQ9B,EAAQqD,mBAAmB1D,EAAIG,QAAQiC,KAAK,IAAMkD,GAE3F,OADAM,OAAOC,OAAOF,EAAkBL,GACzBK,CACT,CACA,SAASJ,EAAoBO,GAC3B,OAAO7F,EAAS,CACd+B,IAAA,IACS8D,KAAU3F,MAEnB,GAAAmC,CAAInC,GACF,MAAM4F,EAAOD,IACTC,IACFA,EAAK5F,MAAQA,EAEjB,GAEJ,CAwEA,SAAS8E,EAAmB5E,EAASL,GAC/BA,KAAOK,EAAQmB,QAAQ0B,OACzB7C,EAAQmB,QAAQ0B,KAAKlD,QAAO,GAE1BA,KAAOK,EAAQmB,QAAQC,UACzBpB,EAAQmB,QAAQC,QAAQzB,GAAOe,EAAkBW,YAE/CrB,EAAQa,WAAWlB,KACrBK,EAAQa,WAAWlB,GAAKkD,KAAK/C,WAAoC,EACjEE,EAAQa,WAAWlB,GAAKoD,MAAMjD,MAAQY,EAAkBW,WAEtDrB,EAAQa,WAAWlB,GAAKmD,QAAQhD,OAAQ,EAE1CE,EAAQa,WAAWlB,GAAKsD,OAAOnD,MAAQ,QAErCH,KAAOK,EAAQqD,qBACbrD,EAAQqD,mBAAmB1D,KAC7BK,EAAQqD,mBAAmB1D,GAAK2D,WAAY,GAE9CtD,EAAQqD,mBAAmB1D,QAAO,EAEtC,CA+HA,MAAMS,EAAa,IAAMM,EAAkBZ,MACrCQ,EAAuB,CAACX,EAAKK,EAAS2F,IACtC3F,EAAQuD,YACHvD,EAAQmB,QAAQ0B,KAAKlD,GAEZ,mBAAdgG,EAAI5E,OAA4C,iBAAd4E,EAAI5E,MACjCf,EAAQ4F,OAAO/C,KAAKlD,QAD7B","x_google_ignoreList":[0]}