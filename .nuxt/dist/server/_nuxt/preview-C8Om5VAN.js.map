{"version":3,"file":"preview-C8Om5VAN.js","sources":["../../../../node_modules/nuxt/dist/app/composables/cookie.js","../../../../node_modules/@nuxt/content/dist/runtime/composables/preview.js"],"sourcesContent":["import { customRef, getCurrentScope, nextTick, onScopeDispose, ref, watch } from \"vue\";\nimport { parse, serialize } from \"cookie-es\";\nimport { deleteCookie, getCookie, getRequestHeader, setCookie } from \"h3\";\nimport destr from \"destr\";\nimport { isEqual } from \"ohash\";\nimport { klona } from \"klona\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { useRequestEvent } from \"./ssr.js\";\nimport { cookieStore } from \"#build/nuxt.config.mjs\";\nconst CookieDefaults = {\n  path: \"/\",\n  watch: true,\n  decode: (val) => destr(decodeURIComponent(val)),\n  encode: (val) => encodeURIComponent(typeof val === \"string\" ? val : JSON.stringify(val))\n};\nconst store = import.meta.client && cookieStore ? globalThis.cookieStore : void 0;\nexport function useCookie(name, _opts) {\n  const opts = { ...CookieDefaults, ..._opts };\n  opts.filter ??= (key) => key === name;\n  const cookies = readRawCookies(opts) || {};\n  let delay;\n  if (opts.maxAge !== void 0) {\n    delay = opts.maxAge * 1e3;\n  } else if (opts.expires) {\n    delay = opts.expires.getTime() - Date.now();\n  }\n  const hasExpired = delay !== void 0 && delay <= 0;\n  const shouldSetInitialClientCookie = import.meta.client && (hasExpired || cookies[name] === void 0 || cookies[name] === null);\n  const cookieValue = klona(hasExpired ? void 0 : cookies[name] ?? opts.default?.());\n  const cookie = import.meta.client && delay && !hasExpired ? cookieRef(cookieValue, delay, opts.watch && opts.watch !== \"shallow\") : ref(cookieValue);\n  if (import.meta.dev && hasExpired) {\n    console.warn(`[nuxt] not setting cookie \\`${name}\\` as it has already expired.`);\n  }\n  if (import.meta.client) {\n    let channel = null;\n    try {\n      if (!store && typeof BroadcastChannel !== \"undefined\") {\n        channel = new BroadcastChannel(`nuxt:cookies:${name}`);\n      }\n    } catch {\n    }\n    const callback = (force = false) => {\n      if (!force) {\n        if (opts.readonly || isEqual(cookie.value, cookies[name])) {\n          return;\n        }\n      }\n      writeClientCookie(name, cookie.value, opts);\n      cookies[name] = klona(cookie.value);\n      channel?.postMessage({ value: opts.encode(cookie.value) });\n    };\n    const handleChange = (data) => {\n      const value = data.refresh ? readRawCookies(opts)?.[name] : opts.decode(data.value);\n      watchPaused = true;\n      cookie.value = value;\n      cookies[name] = klona(value);\n      nextTick(() => {\n        watchPaused = false;\n      });\n    };\n    let watchPaused = false;\n    const hasScope = !!getCurrentScope();\n    if (hasScope) {\n      onScopeDispose(() => {\n        watchPaused = true;\n        callback();\n        channel?.close();\n      });\n    }\n    if (store) {\n      const changeHandler = (event) => {\n        const changedCookie = event.changed.find((c) => c.name === name);\n        const removedCookie = event.deleted.find((c) => c.name === name);\n        if (changedCookie) {\n          handleChange({ value: changedCookie.value });\n        }\n        if (removedCookie) {\n          handleChange({ value: null });\n        }\n      };\n      store.addEventListener(\"change\", changeHandler);\n      if (hasScope) {\n        onScopeDispose(() => store.removeEventListener(\"change\", changeHandler));\n      }\n    } else if (channel) {\n      channel.onmessage = ({ data }) => handleChange(data);\n    }\n    if (opts.watch) {\n      watch(\n        cookie,\n        () => {\n          if (watchPaused) {\n            return;\n          }\n          callback();\n        },\n        { deep: opts.watch !== \"shallow\" }\n      );\n    }\n    if (shouldSetInitialClientCookie) {\n      callback(shouldSetInitialClientCookie);\n    }\n  } else if (import.meta.server) {\n    const nuxtApp = useNuxtApp();\n    const writeFinalCookieValue = () => {\n      if (opts.readonly || isEqual(cookie.value, cookies[name])) {\n        return;\n      }\n      nuxtApp._cookies ||= {};\n      if (name in nuxtApp._cookies) {\n        if (isEqual(cookie.value, nuxtApp._cookies[name])) {\n          return;\n        }\n        if (import.meta.dev) {\n          console.warn(`[nuxt] cookie \\`${name}\\` was previously set to \\`${opts.encode(nuxtApp._cookies[name])}\\` and is being overridden to \\`${opts.encode(cookie.value)}\\`. This may cause unexpected issues.`);\n        }\n      }\n      nuxtApp._cookies[name] = cookie.value;\n      writeServerCookie(useRequestEvent(nuxtApp), name, cookie.value, opts);\n    };\n    const unhook = nuxtApp.hooks.hookOnce(\"app:rendered\", writeFinalCookieValue);\n    nuxtApp.hooks.hookOnce(\"app:error\", () => {\n      unhook();\n      return writeFinalCookieValue();\n    });\n  }\n  return cookie;\n}\nexport function refreshCookie(name) {\n  if (import.meta.server || store || typeof BroadcastChannel === \"undefined\") {\n    return;\n  }\n  new BroadcastChannel(`nuxt:cookies:${name}`)?.postMessage({ refresh: true });\n}\nfunction readRawCookies(opts = {}) {\n  if (import.meta.server) {\n    return parse(getRequestHeader(useRequestEvent(), \"cookie\") || \"\", opts);\n  } else if (import.meta.client) {\n    return parse(document.cookie, opts);\n  }\n}\nfunction serializeCookie(name, value, opts = {}) {\n  if (value === null || value === void 0) {\n    return serialize(name, value, { ...opts, maxAge: -1 });\n  }\n  return serialize(name, value, opts);\n}\nfunction writeClientCookie(name, value, opts = {}) {\n  if (import.meta.client) {\n    document.cookie = serializeCookie(name, value, opts);\n  }\n}\nfunction writeServerCookie(event, name, value, opts = {}) {\n  if (event) {\n    if (value !== null && value !== void 0) {\n      return setCookie(event, name, value, opts);\n    }\n    if (getCookie(event, name) !== void 0) {\n      return deleteCookie(event, name, opts);\n    }\n  }\n}\nconst MAX_TIMEOUT_DELAY = 2147483647;\nfunction cookieRef(value, delay, shouldWatch) {\n  let timeout;\n  let unsubscribe;\n  let elapsed = 0;\n  const internalRef = shouldWatch ? ref(value) : { value };\n  if (getCurrentScope()) {\n    onScopeDispose(() => {\n      unsubscribe?.();\n      clearTimeout(timeout);\n    });\n  }\n  return customRef((track, trigger) => {\n    if (shouldWatch) {\n      unsubscribe = watch(internalRef, trigger);\n    }\n    function createExpirationTimeout() {\n      elapsed = 0;\n      clearTimeout(timeout);\n      const timeRemaining = delay - elapsed;\n      const timeoutLength = timeRemaining < MAX_TIMEOUT_DELAY ? timeRemaining : MAX_TIMEOUT_DELAY;\n      timeout = setTimeout(() => {\n        elapsed += timeoutLength;\n        if (elapsed < delay) {\n          return createExpirationTimeout();\n        }\n        internalRef.value = void 0;\n        trigger();\n      }, timeoutLength);\n    }\n    return {\n      get() {\n        track();\n        return internalRef.value;\n      },\n      set(newValue) {\n        createExpirationTimeout();\n        internalRef.value = newValue;\n        trigger();\n      }\n    };\n  });\n}\n","import { useCookie, useRoute } from \"#imports\";\nlet showWarning = true;\nexport const useContentPreview = () => {\n  const getPreviewToken = () => {\n    return useCookie(\"previewToken\").value || import.meta.client && sessionStorage.getItem(\"previewToken\") || void 0;\n  };\n  const setPreviewToken = (token) => {\n    useCookie(\"previewToken\").value = token;\n    useRoute().query.preview = token || \"\";\n    if (import.meta.client) {\n      if (token) {\n        sessionStorage.setItem(\"previewToken\", token);\n      } else {\n        sessionStorage.removeItem(\"previewToken\");\n      }\n      window.location.reload();\n    }\n  };\n  const isEnabled = () => {\n    const query = useRoute().query;\n    if (Object.prototype.hasOwnProperty.call(query, \"preview\") && !query.preview) {\n      return false;\n    }\n    if (query.preview || useCookie(\"previewToken\").value) {\n      if (import.meta.dev && showWarning) {\n        console.warn(\"[content] Client DB enabled since a preview token is set (either in query or cookie).\");\n        showWarning = false;\n      }\n      return true;\n    }\n    if (import.meta.client && sessionStorage.getItem(\"previewToken\")) {\n      return true;\n    }\n    return false;\n  };\n  return {\n    isEnabled,\n    getPreviewToken,\n    setPreviewToken\n  };\n};\n"],"names":["CookieDefaults","path","watch","decode","val","destr","decodeURIComponent","encode","encodeURIComponent","JSON","stringify","useCookie","name","_opts","opts","filter","key","cookies","parse","getRequestHeader","useRequestEvent","readRawCookies","delay","maxAge","expires","getTime","Date","now","cookieValue","klona","default","cookie","ref","nuxtApp","useNuxtApp","writeFinalCookieValue","readonly","isEqual","value","_cookies","event","setCookie","getCookie","deleteCookie","writeServerCookie","unhook","hooks","hookOnce","useContentPreview","isEnabled","query","useRoute","Object","prototype","hasOwnProperty","call","preview","getPreviewToken","setPreviewToken","token"],"mappings":"gmBASA,MAAMA,EAAiB,CACrBC,KAAM,IACNC,OAAO,EACPC,OAASC,GAAQC,EAAMC,mBAAmBF,IAC1CG,OAASH,GAAQI,mBAAkC,iBAARJ,EAAmBA,EAAMK,KAAKC,UAAUN,KAG9E,SAASO,EAAUC,EAAMC,GAC9B,MAAMC,EAAO,IAAKd,KAAmBa,GACrCC,EAAKC,SAAYC,GAAQA,IAAQJ,EACjC,MAAMK,EAmHR,SAAwBH,EAAO,IAE3B,OAAOI,EAAMC,EAAiBC,IAAmB,WAAa,GAAIN,EAItE,CAzHkBO,CAAeP,IAAS,CAAA,EACxC,IAAIQ,OACgB,IAAhBR,EAAKS,OACPD,EAAsB,IAAdR,EAAKS,OACJT,EAAKU,UACdF,EAAQR,EAAKU,QAAQC,UAAYC,KAAKC,OAExC,MAEMC,EAAcC,OAFS,IAAVP,GAAoBA,GAAS,OAET,EAASL,EAAQL,IAASE,EAAKgB,aAChEC,EAA8HC,EAAIJ,GAyEzG,CAC7B,MAAMK,EAAUC,IACVC,EAAwB,KACxBrB,EAAKsB,UAAYC,EAAQN,EAAOO,MAAOrB,EAAQL,MAGnDqB,EAAQM,WAAa,CAAA,EACjB3B,KAAQqB,EAAQM,UACdF,EAAQN,EAAOO,MAAOL,EAAQM,SAAS3B,MAO7CqB,EAAQM,SAAS3B,GAAQmB,EAAOO,MAmCtC,SAA2BE,EAAO5B,EAAM0B,EAAOxB,EAAO,CAAA,GACpD,GAAI0B,EAAO,CACT,GAAIF,QACF,OAAOG,EAAUD,EAAO5B,EAAM0B,EAAOxB,GAEvC,QAA+B,IAA3B4B,EAAUF,EAAO5B,GACZ+B,EAAaH,EAAO5B,EAAME,EAErC,CACF,CA3CM8B,CAAkBxB,EAAgBa,GAAUrB,EAAMmB,EAAOO,MAAOxB,MAE5D+B,EAASZ,EAAQa,MAAMC,SAAS,eAAgBZ,GACtDF,EAAQa,MAAMC,SAAS,YAAa,KAClCF,IACOV,KAEX,CACA,OAAOJ,CACT,CC7HO,MAAMiB,EAAoB,KAiCxB,CACLC,UAlBgB,KAChB,MAAMC,EAAQC,IAAWD,MACzB,QAAIE,OAAOC,UAAUC,eAAeC,KAAKL,EAAO,aAAeA,EAAMM,aAGjEN,EAAMM,UAAW7C,EAAU,gBAAgB2B,QAc/CmB,gBAlCsB,IACf9C,EAAU,gBAAgB2B,YAAyE,EAkC1GoB,gBAhCuBC,IACvBhD,EAAU,gBAAgB2B,MAAQqB,EAClCR,IAAWD,MAAMM,QAAUG,GAAS","x_google_ignoreList":[0,1]}