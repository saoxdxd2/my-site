import{computed as e,toValue as a,getCurrentInstance as t,onServerPrefetch as r,ref as s,shallowRef as n,toRef as o,nextTick as c,unref as u}from"vue";import{debounce as i}from"C:/Users/sao/Documents/my-site/node_modules/nuxt/node_modules/perfect-debounce/dist/index.mjs";import{e as d,f as l,d as y}from"../server.mjs";import"./client-only-1stTJUAi.js";function f(...f){const D="string"==typeof f[f.length-1]?f.pop():void 0;(function(e,a){if("string"==typeof e)return!1;if("object"==typeof e&&null!==e)return!1;if("function"==typeof e&&"function"==typeof a)return!1;return!0})(f[0],f[1])&&f.unshift(D);let[h,g,P={}]=f;const x=e(()=>a(h));if("string"!=typeof x.value)throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if("function"!=typeof g)throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const C=d();P.server??=!0,P.default??=_,P.getCachedData??=m,P.lazy??=!1,P.immediate??=!0,P.deep??=l.deep,P.dedupe??="cancel",P._functionName,C._asyncData[x.value];const w={cause:"initial",dedupe:P.dedupe};C._asyncData[x.value]?._init||(w.cachedData=P.getCachedData(x.value,C,{cause:"initial"}),C._asyncData[x.value]=function(e,a,t,r,d){e.payload._errors[a]??=l.errorValue;const f=r.getCachedData!==m,v=import.meta.prerender&&e.ssrContext?._sharedPrerenderCache?()=>{const r=e.ssrContext._sharedPrerenderCache.get(a);if(r)return r;const s=Promise.resolve().then(()=>e.runWithContext(()=>t(e)));return e.ssrContext._sharedPrerenderCache.set(a,s),s}:t,_=r.deep?s:n,D=null!=d,h=e.hook("app:data:refresh",async e=>{e&&!e.includes(a)||await g.execute({cause:"refresh:hook"})}),g={data:_(D?d:r.default()),pending:n(!D),error:o(e.payload._errors,a),status:n("idle"),execute:(...t)=>{const[s,n]=t,o=s&&void 0===n&&"object"==typeof s?s:{};if(e._asyncDataPromises[a]){if("defer"===(c=o.dedupe??r.dedupe)||!1===c)return e._asyncDataPromises[a];e._asyncDataPromises[a].cancelled=!0}var c;if("initial"===o.cause||e.isHydrating){const t="cachedData"in o?o.cachedData:r.getCachedData(a,e,{cause:o.cause??"refresh:manual"});if(null!=t)return e.payload.data[a]=g.data.value=t,g.error.value=l.errorValue,g.status.value="success",Promise.resolve(t)}g.pending.value=!0,g.status.value="pending";const i=new Promise((a,t)=>{try{a(v(e))}catch(r){t(r)}}).then(async t=>{if(i.cancelled)return e._asyncDataPromises[a];let s=t;r.transform&&(s=await r.transform(t)),r.pick&&(s=function(e,a){const t={};for(const r of a)t[r]=e[r];return t}(s,r.pick)),e.payload.data[a]=s,g.data.value=s,g.error.value=l.errorValue,g.status.value="success"}).catch(t=>{if(i.cancelled)return e._asyncDataPromises[a];g.error.value=y(t),g.data.value=u(r.default()),g.status.value="error"}).finally(()=>{i.cancelled||(g.pending.value=!1,delete e._asyncDataPromises[a])});return e._asyncDataPromises[a]=i,e._asyncDataPromises[a]},_execute:i((...e)=>g.execute(...e),0,{leading:!0}),_default:r.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{h(),e._asyncData[a]?._init&&(e._asyncData[a]._init=!1),f||c(()=>{e._asyncData[a]?._init||(p(e,a),g.execute=()=>Promise.resolve(),g.data.value=l.value)})}};return g}(C,x.value,g,P,w.cachedData));C._asyncData[x.value]._deps++;if(!1!==P.server&&C.payload.serverRendered&&P.immediate){const e=C._asyncData[x.value].execute(w);t()?r(()=>e):C.hook("app:created",async()=>{await e})}const k={data:v(()=>C._asyncData[x.value]?.data),pending:v(()=>C._asyncData[x.value]?.pending),status:v(()=>C._asyncData[x.value]?.status),error:v(()=>C._asyncData[x.value]?.error),refresh:(...e)=>C._asyncData[x.value].execute(...e),execute:(...e)=>C._asyncData[x.value].execute(...e),clear:()=>p(C,x.value)},b=Promise.resolve(C._asyncDataPromises[x.value]).then(()=>k);return Object.assign(b,k),b}function v(a){return e({get:()=>a()?.value,set(e){const t=a();t&&(t.value=e)}})}function p(e,a){a in e.payload.data&&(e.payload.data[a]=void 0),a in e.payload._errors&&(e.payload._errors[a]=l.errorValue),e._asyncData[a]&&(e._asyncData[a].data.value=void 0,e._asyncData[a].error.value=l.errorValue,e._asyncData[a].pending.value=!1,e._asyncData[a].status.value="idle"),a in e._asyncDataPromises&&(e._asyncDataPromises[a]&&(e._asyncDataPromises[a].cancelled=!0),e._asyncDataPromises[a]=void 0)}const _=()=>l.value,m=(e,a,t)=>a.isHydrating?a.payload.data[e]:"refresh:manual"!==t.cause&&"refresh:hook"!==t.cause?a.static.data[e]:void 0;export{f as u};
//# sourceMappingURL=asyncData-B7xdkuq0.js.map
